var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    
    require.define = function (filename, fn) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n    \n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n    \n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"));

require.define("/lib/sequence.js",Function(['require','module','exports','__dirname','__filename','process'],"var merge = (require(\"./runtime\")).merge;\nvar inc = (require(\"./runtime\")).inc;\nvar dec = (require(\"./runtime\")).dec;\nvar str = (require(\"./runtime\")).str;\nvar keyValues = (require(\"./runtime\")).keyValues;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isString = (require(\"./runtime\")).isString;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isFn = (require(\"./runtime\")).isFn;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNil = (require(\"./runtime\")).isNil;;\n\nvar List = function List(head, tail) {\n  this.head = head;\n  this.tail = tail || (list());\n  this.length = inc(count(this.tail));\n  return this;\n};\n\nList.prototype.length = 0;\n\nList.type = \"wisp.list\";\n\nList.prototype.type = List.type;\n\nList.prototype.tail = Object.create(List.prototype);\n\nList.prototype.toString = function() {\n  return (function loop(result, list) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(list) ?\n      \"\" + \"(\" + (result.substr(1)) + \")\" :\n      (result = \"\" + result + \" \" + (isVector(first(list)) ?\n        \"\" + \"[\" + (first(list).join(\" \")) + \"]\" :\n      isNil(first(list)) ?\n        \"nil\" :\n      isString(first(list)) ?\n        JSON.stringify(first(list)) :\n      isNumber(first(list)) ?\n        JSON.stringify(first(list)) :\n        first(list)), list = rest(list), loop);\n    };\n    return recur;\n  })(\"\", this);\n};\n\nvar lazySeqValue = function lazySeqValue(lazySeq) {\n  return !(lazySeq.realized) ?\n    (lazySeq.realized = true) && (lazySeq.x = lazySeq.x()) :\n    lazySeq.x;\n};\n\nvar LazySeq = function LazySeq(realized, x) {\n  this.realized = realized || false;\n  this.x = x;\n  return this;\n};\n\nLazySeq.type = \"wisp.lazy.seq\";\n\nLazySeq.prototype.type = LazySeq.type;\n\nvar lazySeq = function lazySeq(realized, body) {\n  return new LazySeq(realized, body);\n};\nexports.lazySeq = lazySeq;\n\nvar isLazySeq = function isLazySeq(value) {\n  return value && (LazySeq.type === value.type);\n};\nexports.isLazySeq = isLazySeq;\n\n;\n\nvar isList = function isList(value) {\n  return value && (List.type === value.type);\n};\nexports.isList = isList;\n\nvar list = function list() {\n  return arguments.length === 0 ?\n    Object.create(List.prototype) :\n    Array.prototype.slice.call(arguments).reduceRight(function(tail, head) {\n      return cons(head, tail);\n    }, list());\n};\nexports.list = list;\n\nvar cons = function cons(head, tail) {\n  return new List(head, tail);\n};\nexports.cons = cons;\n\nvar reverseList = function reverseList(sequence) {\n  return (function loop(items, source) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(source) ?\n      list.apply(list, items) :\n      (items = [first(source)].concat(items), source = rest(source), loop);\n    };\n    return recur;\n  })([], sequence);\n};\n\nvar isSequential = function isSequential(x) {\n  return (isList(x)) || (isVector(x)) || (isLazySeq(x)) || (isDictionary(x)) || (isString(x));\n};\nexports.isSequential = isSequential;\n\nvar reverse = function reverse(sequence) {\n  return isList(sequence) ?\n    reverseList(sequence) :\n  isVector(sequence) ?\n    sequence.reverse() :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    reverse(seq(sequence)) :\n    void(0);\n};\nexports.reverse = reverse;\n\nvar map = function map(f, sequence) {\n  return isVector(sequence) ?\n    sequence.map(f) :\n  isList(sequence) ?\n    mapList(f, sequence) :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    map(f, seq(sequence)) :\n    void(0);\n};\nexports.map = map;\n\nvar mapList = function mapList(f, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      reverse(result) :\n      (result = cons(f(first(items)), result), items = rest(items), loop);\n    };\n    return recur;\n  })(list(), sequence);\n};\n\nvar filter = function filter(isF, sequence) {\n  return isVector(sequence) ?\n    sequence.filter(isF) :\n  isList(sequence) ?\n    filterList(isF, sequence) :\n  isNil(sequence) ?\n    list() :\n  \"else\" ?\n    filter(isF, seq(sequence)) :\n    void(0);\n};\nexports.filter = filter;\n\nvar filterList = function filterList(isF, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      reverse(result) :\n      (result = isF(first(items)) ?\n        cons(first(items), result) :\n        result, items = rest(items), loop);\n    };\n    return recur;\n  })(list(), sequence);\n};\n\nvar reduce = function reduce(f) {\n  var params = Array.prototype.slice.call(arguments, 1);\n  return (function() {\n    var hasInitial = count(params) >= 2;\n    var initial = hasInitial ?\n      first(params) :\n      void(0);\n    var sequence = hasInitial ?\n      second(params) :\n      first(params);\n    return isNil(sequence) ?\n      initial :\n    isVector(sequence) ?\n      hasInitial ?\n        sequence.reduce(f, initial) :\n        sequence.reduce(f) :\n    isList(sequence) ?\n      hasInitial ?\n        reduceList(f, initial, sequence) :\n        reduceList(f, first(sequence), rest(sequence)) :\n    \"else\" ?\n      reduce(f, initial, seq(sequence)) :\n      void(0);\n  })();\n};\nexports.reduce = reduce;\n\nvar reduceList = function reduceList(f, initial, sequence) {\n  return (function loop(result, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      result :\n      (result = f(result, first(items)), items = rest(items), loop);\n    };\n    return recur;\n  })(initial, sequence);\n};\n\nvar count = function count(sequence) {\n  return isNil(sequence) ?\n    0 :\n    (seq(sequence)).length;\n};\nexports.count = count;\n\nvar isEmpty = function isEmpty(sequence) {\n  return count(sequence) === 0;\n};\nexports.isEmpty = isEmpty;\n\nvar first = function first(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    sequence.head :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[0] :\n  isLazySeq(sequence) ?\n    first(lazySeqValue(sequence)) :\n  \"else\" ?\n    first(seq(sequence)) :\n    void(0);\n};\nexports.first = first;\n\nvar second = function second(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    first(rest(sequence)) :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[1] :\n  isLazySeq(sequence) ?\n    second(lazySeqValue(sequence)) :\n  \"else\" ?\n    first(rest(seq(sequence))) :\n    void(0);\n};\nexports.second = second;\n\nvar third = function third(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  isList(sequence) ?\n    first(rest(rest(sequence))) :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence[2] :\n  isLazySeq(sequence) ?\n    third(lazySeqValue(sequence)) :\n  \"else\" ?\n    second(rest(seq(sequence))) :\n    void(0);\n};\nexports.third = third;\n\nvar rest = function rest(sequence) {\n  return isNil(sequence) ?\n    list() :\n  isList(sequence) ?\n    sequence.tail :\n  (isVector(sequence)) || (isString(sequence)) ?\n    sequence.slice(1) :\n  isLazySeq(sequence) ?\n    rest(lazySeqValue(sequence)) :\n  \"else\" ?\n    rest(seq(sequence)) :\n    void(0);\n};\nexports.rest = rest;\n\nvar lastOfList = function lastOfList(list) {\n  return (function loop(item, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(items) ?\n      item :\n      (item = first(items), items = rest(items), loop);\n    };\n    return recur;\n  })(first(list), rest(list));\n};\n\nvar last = function last(sequence) {\n  return (isVector(sequence)) || (isString(sequence)) ?\n    sequence[dec(count(sequence))] :\n  isList(sequence) ?\n    lastOfList(sequence) :\n  isNil(sequence) ?\n    void(0) :\n  isLazySeq(sequence) ?\n    last(lazySeqValue(sequence)) :\n  \"else\" ?\n    last(seq(sequence)) :\n    void(0);\n};\nexports.last = last;\n\nvar butlast = function butlast(sequence) {\n  var items = isNil(sequence) ?\n    void(0) :\n  isString(sequence) ?\n    subs(sequence, 0, dec(count(sequence))) :\n  isVector(sequence) ?\n    sequence.slice(0, dec(count(sequence))) :\n  isList(sequence) ?\n    list.apply(list, butlast(vec(sequence))) :\n  isLazySeq(sequence) ?\n    butlast(lazySeqValue(sequence)) :\n  \"else\" ?\n    butlast(seq(sequence)) :\n    void(0);\n  return !((isNil(items)) || (isEmpty(items))) ?\n    items :\n    void(0);\n};\nexports.butlast = butlast;\n\nvar take = function take(n, sequence) {\n  return isNil(sequence) ?\n    list() :\n  isVector(sequence) ?\n    takeFromVector(n, sequence) :\n  isList(sequence) ?\n    takeFromList(n, sequence) :\n  isLazySeq(sequence) ?\n    take(n, lazySeqValue(sequence)) :\n  \"else\" ?\n    take(n, seq(sequence)) :\n    void(0);\n};\nexports.take = take;\n\nvar takeFromVector = function takeFromVector(n, vector) {\n  return vector.slice(0, n);\n};\n\nvar takeFromList = function takeFromList(n, sequence) {\n  return (function loop(taken, items, n) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (n === 0) || (isEmpty(items)) ?\n      reverse(taken) :\n      (taken = cons(first(items), taken), items = rest(items), n = dec(n), loop);\n    };\n    return recur;\n  })(list(), sequence, n);\n};\n\nvar dropFromList = function dropFromList(n, sequence) {\n  return (function loop(left, items) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (left < 1) || (isEmpty(items)) ?\n      items :\n      (left = dec(left), items = rest(items), loop);\n    };\n    return recur;\n  })(n, sequence);\n};\n\nvar drop = function drop(n, sequence) {\n  return n <= 0 ?\n    sequence :\n  isString(sequence) ?\n    sequence.substr(n) :\n  isVector(sequence) ?\n    sequence.slice(n) :\n  isList(sequence) ?\n    dropFromList(n, sequence) :\n  isNil(sequence) ?\n    list() :\n  isLazySeq(sequence) ?\n    drop(n, lazySeqValue(sequence)) :\n  \"else\" ?\n    drop(n, seq(sequence)) :\n    void(0);\n};\nexports.drop = drop;\n\nvar conjList = function conjList(sequence, items) {\n  return reduce(function(result, item) {\n    return cons(item, result);\n  }, sequence, items);\n};\n\nvar conj = function conj(sequence) {\n  var items = Array.prototype.slice.call(arguments, 1);\n  return isVector(sequence) ?\n    sequence.concat(items) :\n  isString(sequence) ?\n    \"\" + sequence + (str.apply(str, items)) :\n  isNil(sequence) ?\n    list.apply(list, reverse(items)) :\n  (isList(sequence)) || (isLazySeq()) ?\n    conjList(sequence, items) :\n  isDictionary(sequence) ?\n    merge(sequence, merge.apply(merge, items)) :\n  \"else\" ?\n    (function() { throw TypeError(\"\" + \"Type can't be conjoined \" + sequence); })() :\n    void(0);\n};\nexports.conj = conj;\n\nvar concat = function concat() {\n  var sequences = Array.prototype.slice.call(arguments, 0);\n  return reverse(reduce(function(result, sequence) {\n    return reduce(function(result, item) {\n      return cons(item, result);\n    }, result, seq(sequence));\n  }, list(), sequences));\n};\nexports.concat = concat;\n\nvar seq = function seq(sequence) {\n  return isNil(sequence) ?\n    void(0) :\n  (isVector(sequence)) || (isList(sequence)) || (isLazySeq(sequence)) ?\n    sequence :\n  isString(sequence) ?\n    Array.prototype.slice.call(sequence) :\n  isDictionary(sequence) ?\n    keyValues(sequence) :\n  \"default\" ?\n    (function() { throw TypeError(\"\" + \"Can not seq \" + sequence); })() :\n    void(0);\n};\nexports.seq = seq;\n\nvar listToVector = function listToVector(source) {\n  return (function loop(result, list) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(list) ?\n      result :\n      (result = (function() {\n        result.push(first(list));\n        return result;\n      })(), list = rest(list), loop);\n    };\n    return recur;\n  })([], source);\n};\n\nvar vec = function vec(sequence) {\n  return isNil(sequence) ?\n    [] :\n  isVector(sequence) ?\n    sequence :\n  isList(sequence) ?\n    listToVector(sequence) :\n  \"else\" ?\n    vec(seq(sequence)) :\n    void(0);\n};\nexports.vec = vec;\n\nvar sort = function sort(f, items) {\n  var hasComparator = isFn(f);\n  var items = (!(hasComparator)) && (isNil(items)) ?\n    f :\n    items;\n  var compare = hasComparator ?\n    function(a, b) {\n      return f(a, b) ?\n        0 :\n        1;\n    } :\n    void(0);\n  return isNil(items) ?\n    list() :\n  isVector(items) ?\n    items.sort(compare) :\n  isList(items) ?\n    list.apply(list, vec(items).sort(compare)) :\n  isDictionary(items) ?\n    seq(items).sort(compare) :\n  \"else\" ?\n    sort(f, seq(items)) :\n    void(0);\n};\nexports.sort = sort\n\n//@ sourceURL=/lib/sequence.js"));

require.define("/lib/runtime.js",Function(['require','module','exports','__dirname','__filename','process'],"var isOdd = function isOdd(n) {\n  return n % 2 === 1;\n};\nexports.isOdd = isOdd;\n\nvar isEven = function isEven(n) {\n  return n % 2 === 0;\n};\nexports.isEven = isEven;\n\nvar isDictionary = function isDictionary(form) {\n  return (isObject(form)) && (isObject(Object.getPrototypeOf(form))) && (isNil(Object.getPrototypeOf(Object.getPrototypeOf(form))));\n};\nexports.isDictionary = isDictionary;\n\nvar dictionary = function dictionary() {\n  return (function loop(keyValues, result) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = keyValues.length ?\n      (function() {\n        result[keyValues[0]] = keyValues[1];\n        return (keyValues = keyValues.slice(2), result = result, loop);\n      })() :\n      result;\n    };\n    return recur;\n  })(Array.prototype.slice.call(arguments), {});\n};\nexports.dictionary = dictionary;\n\nvar keys = function keys(dictionary) {\n  return Object.keys(dictionary);\n};\nexports.keys = keys;\n\nvar vals = function vals(dictionary) {\n  return keys(dictionary).map(function(key) {\n    return dictionary[key];\n  });\n};\nexports.vals = vals;\n\nvar keyValues = function keyValues(dictionary) {\n  return keys(dictionary).map(function(key) {\n    return [key, dictionary[key]];\n  });\n};\nexports.keyValues = keyValues;\n\nvar merge = function merge() {\n  return Object.create(Object.prototype, Array.prototype.slice.call(arguments).reduce(function(descriptor, dictionary) {\n    isObject(dictionary) ?\n      Object.keys(dictionary).forEach(function(key) {\n        return descriptor[key] = Object.getOwnPropertyDescriptor(dictionary, key);\n      }) :\n      void(0);\n    return descriptor;\n  }, Object.create(Object.prototype)));\n};\nexports.merge = merge;\n\nvar isContainsVector = function isContainsVector(vector, element) {\n  return vector.indexOf(element) >= 0;\n};\nexports.isContainsVector = isContainsVector;\n\nvar mapDictionary = function mapDictionary(source, f) {\n  return Object.keys(source).reduce(function(target, key) {\n    target[key] = f(source[key]);\n    return target;\n  }, {});\n};\nexports.mapDictionary = mapDictionary;\n\nvar toString = Object.prototype.toString;\nexports.toString = toString;\n\nvar isFn = typeof(/./) === \"function\" ?\n  function isFn(x) {\n    return toString.call(x) === \"[object Function]\";\n  } :\n  function isFn(x) {\n    return typeof(x) === \"function\";\n  };\nexports.isFn = isFn;\n\nvar isString = function isString(x) {\n  return (typeof(x) === \"string\") || (toString.call(x) === \"[object String]\");\n};\nexports.isString = isString;\n\nvar isNumber = function isNumber(x) {\n  return (typeof(x) === \"number\") || (toString.call(x) === \"[object Number]\");\n};\nexports.isNumber = isNumber;\n\nvar isVector = isFn(Array.isArray) ?\n  Array.isArray :\n  function isVector(x) {\n    return toString.call(x) === \"[object Array]\";\n  };\nexports.isVector = isVector;\n\nvar isDate = function isDate(x) {\n  return toString.call(x) === \"[object Date]\";\n};\nexports.isDate = isDate;\n\nvar isBoolean = function isBoolean(x) {\n  return (x === true) || (x === false) || (toString.call(x) === \"[object Boolean]\");\n};\nexports.isBoolean = isBoolean;\n\nvar isRePattern = function isRePattern(x) {\n  return toString.call(x) === \"[object RegExp]\";\n};\nexports.isRePattern = isRePattern;\n\nvar isObject = function isObject(x) {\n  return x && (typeof(x) === \"object\");\n};\nexports.isObject = isObject;\n\nvar isNil = function isNil(x) {\n  return (x === void(0)) || (x === null);\n};\nexports.isNil = isNil;\n\nvar isTrue = function isTrue(x) {\n  return x === true;\n};\nexports.isTrue = isTrue;\n\nvar isFalse = function isFalse(x) {\n  return x === true;\n};\nexports.isFalse = isFalse;\n\nvar reFind = function reFind(re, s) {\n  var matches = re.exec(s);\n  return !(isNil(matches)) ?\n    matches.length === 1 ?\n      matches[0] :\n      matches :\n    void(0);\n};\nexports.reFind = reFind;\n\nvar reMatches = function reMatches(pattern, source) {\n  var matches = pattern.exec(source);\n  return (!(isNil(matches))) && (matches[0] === source) ?\n    matches.length === 1 ?\n      matches[0] :\n      matches :\n    void(0);\n};\nexports.reMatches = reMatches;\n\nvar rePattern = function rePattern(s) {\n  var match = reFind(/^(?:\\(\\?([idmsux]*)\\))?(.*)/, s);\n  return new RegExp(match[2], match[1]);\n};\nexports.rePattern = rePattern;\n\nvar inc = function inc(x) {\n  return x + 1;\n};\nexports.inc = inc;\n\nvar dec = function dec(x) {\n  return x - 1;\n};\nexports.dec = dec;\n\nvar str = function str() {\n  return String.prototype.concat.apply(\"\", arguments);\n};\nexports.str = str;\n\nvar char = function char(code) {\n  return String.fromCharCode(code);\n};\nexports.char = char;\n\nvar int = function int(x) {\n  return isNumber(x) ?\n    x >= 0 ?\n      Math.floor(x) :\n      Math.floor(x) :\n    x.charCodeAt(0);\n};\nexports.int = int;\n\nvar subs = function subs(string, start, end) {\n  return string.substring(start, end);\n};\nexports.subs = subs;\n\nvar isPatternEqual = function isPatternEqual(x, y) {\n  return (isRePattern(x)) && (isRePattern(y)) && (x.source === y.source) && (x.global === y.global) && (x.multiline === y.multiline) && (x.ignoreCase === y.ignoreCase);\n};\n\nvar isDateEqual = function isDateEqual(x, y) {\n  return (isDate(x)) && (isDate(y)) && (Number(x) === Number(y));\n};\n\nvar isDictionaryEqual = function isDictionaryEqual(x, y) {\n  return (isObject(x)) && (isObject(y)) && ((function() {\n    var xKeys = keys(x);\n    var yKeys = keys(y);\n    var xCount = xKeys.length;\n    var yCount = yKeys.length;\n    return (xCount === yCount) && ((function loop(index, count, keys) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = index < count ?\n        isEquivalent(x[keys[index]], y[keys[index]]) ?\n          (index = inc(index), count = count, keys = keys, loop) :\n          false :\n        true;\n      };\n      return recur;\n    })(0, xCount, xKeys));\n  })());\n};\n\nvar isVectorEqual = function isVectorEqual(x, y) {\n  return (isVector(x)) && (isVector(y)) && (x.length === y.length) && ((function loop(xs, ys, index, count) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = index < count ?\n      isEquivalent(xs[index], ys[index]) ?\n        (xs = xs, ys = ys, index = inc(index), count = count, loop) :\n        false :\n      true;\n    };\n    return recur;\n  })(x, y, 0, x.length));\n};\n\nvar isEquivalent = function isEquivalent(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return (x === y) || (isNil(x) ?\n        isNil(y) :\n      isNil(y) ?\n        isNil(x) :\n      isString(x) ?\n        false :\n      isNumber(x) ?\n        false :\n      isFn(x) ?\n        false :\n      isBoolean(x) ?\n        false :\n      isDate(x) ?\n        isDateEqual(x, y) :\n      isVector(x) ?\n        isVectorEqual(x, y, [], []) :\n      isRePattern(x) ?\n        isPatternEqual(x, y) :\n      \"else\" ?\n        isDictionaryEqual(x, y) :\n        void(0));\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (isEquivalent(previous, current)) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\n\nvar isEqual = isEquivalent;\nexports.isEqual = isEqual;\n\nvar isStrictEqual = function isStrictEqual(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x === y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous === current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.isStrictEqual = isStrictEqual;\n\nvar greaterThan = function greaterThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x > y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous > current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.greaterThan = greaterThan;\n\nvar notLessThan = function notLessThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x >= y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous >= current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.notLessThan = notLessThan;\n\nvar lessThan = function lessThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x < y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous < current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.lessThan = lessThan;\n\nvar notGreaterThan = function notGreaterThan(x, y) {\n  switch (arguments.length) {\n    case 1:\n      return true;\n    case 2:\n      return x <= y;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 2);\n      return (function loop(previous, current, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = (previous <= current) && (index < count ?\n          (previous = current, current = more[index], index = inc(index), count = count, loop) :\n          true);\n        };\n        return recur;\n      })(x, y, 0, more.length);\n  };\n  return void(0);\n};\nexports.notGreaterThan = notGreaterThan;\n\nvar sum = function sum(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return 0;\n    case 1:\n      return a;\n    case 2:\n      return a + b;\n    case 3:\n      return a + b + c;\n    case 4:\n      return a + b + c + d;\n    case 5:\n      return a + b + c + d + e;\n    case 6:\n      return a + b + c + d + e + f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value + (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a + b + c + d + e + f, 0, more.length);\n  };\n  return void(0);\n};\nexports.sum = sum;\n\nvar subtract = function subtract(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return (function() { throw TypeError(\"Wrong number of args passed to: -\"); })();\n    case 1:\n      return 0 - a;\n    case 2:\n      return a - b;\n    case 3:\n      return a - b - c;\n    case 4:\n      return a - b - c - d;\n    case 5:\n      return a - b - c - d - e;\n    case 6:\n      return a - b - c - d - e - f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value - (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a - b - c - d - e - f, 0, more.length);\n  };\n  return void(0);\n};\nexports.subtract = subtract;\n\nvar divide = function divide(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return (function() { throw TypeError(\"Wrong number of args passed to: /\"); })();\n    case 1:\n      return 1 / a;\n    case 2:\n      return a / b;\n    case 3:\n      return a / b / c;\n    case 4:\n      return a / b / c / d;\n    case 5:\n      return a / b / c / d / e;\n    case 6:\n      return a / b / c / d / e / f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value / (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a / b / c / d / e / f, 0, more.length);\n  };\n  return void(0);\n};\nexports.divide = divide;\n\nvar multiply = function multiply(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return 1;\n    case 1:\n      return a;\n    case 2:\n      return a * b;\n    case 3:\n      return a * b * c;\n    case 4:\n      return a * b * c * d;\n    case 5:\n      return a * b * c * d * e;\n    case 6:\n      return a * b * c * d * e * f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value * (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a * b * c * d * e * f, 0, more.length);\n  };\n  return void(0);\n};\nexports.multiply = multiply;\n\nvar and = function and(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return true;\n    case 1:\n      return a;\n    case 2:\n      return a && b;\n    case 3:\n      return a && b && c;\n    case 4:\n      return a && b && c && d;\n    case 5:\n      return a && b && c && d && e;\n    case 6:\n      return a && b && c && d && e && f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value && (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a && b && c && d && e && f, 0, more.length);\n  };\n  return void(0);\n};\nexports.and = and;\n\nvar or = function or(a, b, c, d, e, f) {\n  switch (arguments.length) {\n    case 0:\n      return void(0);\n    case 1:\n      return a;\n    case 2:\n      return a || b;\n    case 3:\n      return a || b || c;\n    case 4:\n      return a || b || c || d;\n    case 5:\n      return a || b || c || d || e;\n    case 6:\n      return a || b || c || d || e || f;\n    \n    default:\n      var more = Array.prototype.slice.call(arguments, 6);\n      return (function loop(value, index, count) {\n        var recur = loop;\n        while (recur === loop) {\n          recur = index < count ?\n          (value = value || (more[index]), index = inc(index), count = count, loop) :\n          value;\n        };\n        return recur;\n      })(a || b || c || d || e || f, 0, more.length);\n  };\n  return void(0);\n};\nexports.or = or\n\n//@ sourceURL=/lib/runtime.js"));

require.define("/lib/engine/browser.js",Function(['require','module','exports','__dirname','__filename','process'],"var str = (require(\"../runtime\")).str;;\n\nvar rest = (require(\"../sequence\")).rest;;\n\nvar readFromString = (require(\"../reader\")).readFromString;;\n\nvar compileProgram = (require(\"../compiler\")).compileProgram;;\n\nvar transpile = function transpile(source, uri) {\n  return \"\" + (compileProgram(rest(readFromString(\"\" + \"(do \" + source + \")\", uri)))) + \"\\n\";\n};\nexports.transpile = transpile;\n\nvar evaluate = function evaluate(code, url) {\n  return eval(transpile(code, url));\n};\nexports.evaluate = evaluate;\n\nvar run = function run(code, url) {\n  return (Function(transpile(code, url)))();\n};\nexports.run = run;\n\nvar load = function load(url, callback) {\n  var request = window.XMLHttpRequest ?\n    new XMLHttpRequest() :\n    new ActiveXObject(\"Microsoft.XMLHTTP\");\n  request.open(\"GET\", url, true);\n  request.overrideMimeType ?\n    request.overrideMimeType(\"application/wisp\") :\n    void(0);\n  request.onreadystatechange = function() {\n    return request.readyState === 4 ?\n      (request.status === 0) || (request.status === 200) ?\n        callback(run(request.responseText, url)) :\n        callback(\"Could not load\") :\n      void(0);\n  };\n  return request.send(null);\n};\nexports.load = load;\n\nvar runScripts = function runScripts() {\n  var scripts = Array.prototype.filter.call(document.getElementsByTagName(\"script\"), function(script) {\n    return script.type === \"application/wisp\";\n  });\n  var next = function next() {\n    return scripts.length ?\n      (function() {\n        var script = scripts.shift();\n        return script.src ?\n          load(script.src, next) :\n          next(run(script.innerHTML));\n      })() :\n      void(0);\n  };\n  return next();\n};\nexports.runScripts = runScripts;\n\n(document.readyState === \"complete\") || (document.readyState === \"interactive\") ?\n  runScripts() :\nwindow.addEventListener ?\n  window.addEventListener(\"DOMContentLoaded\", runScripts, false) :\n  window.attachEvent(\"onload\", runScripts)\n\n//@ sourceURL=/lib/engine/browser.js"));

require.define("/lib/reader.js",Function(['require','module','exports','__dirname','__filename','process'],"var sort = (require(\"./sequence\")).sort;\nvar butlast = (require(\"./sequence\")).butlast;\nvar last = (require(\"./sequence\")).last;\nvar concat = (require(\"./sequence\")).concat;\nvar rest = (require(\"./sequence\")).rest;\nvar conj = (require(\"./sequence\")).conj;\nvar cons = (require(\"./sequence\")).cons;\nvar vec = (require(\"./sequence\")).vec;\nvar map = (require(\"./sequence\")).map;\nvar rest = (require(\"./sequence\")).rest;\nvar third = (require(\"./sequence\")).third;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar isEmpty = (require(\"./sequence\")).isEmpty;\nvar count = (require(\"./sequence\")).count;\nvar isList = (require(\"./sequence\")).isList;\nvar list = (require(\"./sequence\")).list;;\n\nvar isStrictEqual = (require(\"./runtime\")).isStrictEqual;\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar vals = (require(\"./runtime\")).vals;\nvar char = (require(\"./runtime\")).char;\nvar subs = (require(\"./runtime\")).subs;\nvar str = (require(\"./runtime\")).str;\nvar reFind = (require(\"./runtime\")).reFind;\nvar reMatches = (require(\"./runtime\")).reMatches;\nvar rePattern = (require(\"./runtime\")).rePattern;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isObject = (require(\"./runtime\")).isObject;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isString = (require(\"./runtime\")).isString;\nvar isVector = (require(\"./runtime\")).isVector;\nvar dec = (require(\"./runtime\")).dec;\nvar inc = (require(\"./runtime\")).inc;\nvar isNil = (require(\"./runtime\")).isNil;\nvar keys = (require(\"./runtime\")).keys;\nvar dictionary = (require(\"./runtime\")).dictionary;\nvar isOdd = (require(\"./runtime\")).isOdd;;\n\nvar name = (require(\"./ast\")).name;\nvar withMeta = (require(\"./ast\")).withMeta;\nvar meta = (require(\"./ast\")).meta;\nvar keyword = (require(\"./ast\")).keyword;\nvar isKeyword = (require(\"./ast\")).isKeyword;\nvar symbol = (require(\"./ast\")).symbol;\nvar isSymbol = (require(\"./ast\")).isSymbol;;\n\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar pushBackReader = function pushBackReader(source, uri) {\n  return {\n    \"lines\": split(source, \"\\n\"),\n    \"buffer\": \"\",\n    \"uri\": uri,\n    \"column\": -1,\n    \"line\": 0\n  };\n};\nexports.pushBackReader = pushBackReader;\n\nvar peekChar = function peekChar(reader) {\n  var line = ((reader || 0)[\"lines\"])[(reader || 0)[\"line\"]];\n  var column = inc((reader || 0)[\"column\"]);\n  return isNil(line) ?\n    void(0) :\n    (line[column]) || \"\\n\";\n};\nexports.peekChar = peekChar;\n\nvar readChar = function readChar(reader) {\n  var ch = peekChar(reader);\n  isNewline(peekChar(reader)) ?\n    (function() {\n      (reader || 0)[\"line\"] = inc((reader || 0)[\"line\"]);\n      return (reader || 0)[\"column\"] = -1;\n    })() :\n    (reader || 0)[\"column\"] = inc((reader || 0)[\"column\"]);\n  return ch;\n};\nexports.readChar = readChar;\n\nvar isNewline = function isNewline(ch) {\n  return \"\\n\" === ch;\n};\nexports.isNewline = isNewline;\n\nvar isBreakingWhitespace = function isBreakingWhitespace(ch) {\n  return (ch === \" \") || (ch === \"\\t\") || (ch === \"\\n\") || (ch === \"\\r\");\n};\nexports.isBreakingWhitespace = isBreakingWhitespace;\n\nvar isWhitespace = function isWhitespace(ch) {\n  return (isBreakingWhitespace(ch)) || (\",\" === ch);\n};\nexports.isWhitespace = isWhitespace;\n\nvar isNumeric = function isNumeric(ch) {\n  return (ch === \"0\") || (ch === \"1\") || (ch === \"2\") || (ch === \"3\") || (ch === \"4\") || (ch === \"5\") || (ch === \"6\") || (ch === \"7\") || (ch === \"8\") || (ch === \"9\");\n};\nexports.isNumeric = isNumeric;\n\nvar isCommentPrefix = function isCommentPrefix(ch) {\n  return \";\" === ch;\n};\nexports.isCommentPrefix = isCommentPrefix;\n\nvar isNumberLiteral = function isNumberLiteral(reader, initch) {\n  return (isNumeric(initch)) || (((\"+\" === initch) || (\"-\" === initch)) && (isNumeric(peekChar(reader))));\n};\nexports.isNumberLiteral = isNumberLiteral;\n\nvar readerError = function readerError(reader, message) {\n  var text = \"\" + message + \"\\n\" + \"line:\" + ((reader || 0)[\"line\"]) + \"\\n\" + \"column:\" + ((reader || 0)[\"column\"]);\n  var error = SyntaxError(text, (reader || 0)[\"uri\"]);\n  error.line = (reader || 0)[\"line\"];\n  error.column = (reader || 0)[\"column\"];\n  error.uri = (reader || 0)[\"uri\"];\n  return (function() { throw error; })();\n};\nexports.readerError = readerError;\n\nvar isMacroTerminating = function isMacroTerminating(ch) {\n  return (!(ch === \"#\")) && (!(ch === \"'\")) && (!(ch === \":\")) && (macros(ch));\n};\nexports.isMacroTerminating = isMacroTerminating;\n\nvar readToken = function readToken(reader, initch) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (isWhitespace(ch)) || (isMacroTerminating(ch)) ?\n      buffer :\n      (buffer = \"\" + buffer + (readChar(reader)), ch = peekChar(reader), loop);\n    };\n    return recur;\n  })(initch, peekChar(reader));\n};\nexports.readToken = readToken;\n\nvar skipLine = function skipLine(reader, _) {\n  return (function loop() {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readChar(reader);\n      return (ch === \"\\n\") || (ch === \"\\r\") || (isNil(ch)) ?\n        reader :\n        (loop);\n    })();\n    };\n    return recur;\n  })();\n};\nexports.skipLine = skipLine;\n\nvar intPattern = rePattern(\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\");\nexports.intPattern = intPattern;\n\nvar ratioPattern = rePattern(\"([-+]?[0-9]+)/([0-9]+)\");\nexports.ratioPattern = ratioPattern;\n\nvar floatPattern = rePattern(\"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\");\nexports.floatPattern = floatPattern;\n\nvar matchInt = function matchInt(s) {\n  var groups = reFind(intPattern, s);\n  var group3 = groups[2];\n  return !((isNil(group3)) || (count(group3) < 1)) ?\n    0 :\n    (function() {\n      var negate = \"-\" === groups[1] ?\n        -1 :\n        1;\n      var a = groups[3] ?\n        [groups[3], 10] :\n      groups[4] ?\n        [groups[4], 16] :\n      groups[5] ?\n        [groups[5], 8] :\n      groups[7] ?\n        [groups[7], parseInt(groups[7])] :\n      \"else\" ?\n        [void(0), void(0)] :\n        void(0);\n      var n = a[0];\n      var radix = a[1];\n      return isNil(n) ?\n        void(0) :\n        negate * (parseInt(n, radix));\n    })();\n};\nexports.matchInt = matchInt;\n\nvar matchRatio = function matchRatio(s) {\n  var groups = reFind(ratioPattern, s);\n  var numinator = groups[1];\n  var denominator = groups[2];\n  return (parseInt(numinator)) / (parseInt(denominator));\n};\nexports.matchRatio = matchRatio;\n\nvar matchFloat = function matchFloat(s) {\n  return parseFloat(s);\n};\nexports.matchFloat = matchFloat;\n\nvar matchNumber = function matchNumber(s) {\n  return reMatches(intPattern, s) ?\n    matchInt(s) :\n  reMatches(ratioPattern, s) ?\n    matchRatio(s) :\n  reMatches(floatPattern, s) ?\n    matchFloat(s) :\n    void(0);\n};\nexports.matchNumber = matchNumber;\n\nvar escapeCharMap = function escapeCharMap(c) {\n  return c === \"t\" ?\n    \"\\t\" :\n  c === \"r\" ?\n    \"\\r\" :\n  c === \"n\" ?\n    \"\\n\" :\n  c === \"\\\\\" ?\n    \"\\\\\" :\n  c === \"\\\"\" ?\n    \"\\\"\" :\n  c === \"b\" ?\n    \"\b\" :\n  c === \"f\" ?\n    \"\f\" :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.escapeCharMap = escapeCharMap;\n\nvar read2Chars = function read2Chars(reader) {\n  return \"\" + (readChar(reader)) + (readChar(reader));\n};\nexports.read2Chars = read2Chars;\n\nvar read4Chars = function read4Chars(reader) {\n  return \"\" + (readChar(reader)) + (readChar(reader)) + (readChar(reader)) + (readChar(reader));\n};\nexports.read4Chars = read4Chars;\n\nvar unicode2Pattern = rePattern(\"[0-9A-Fa-f]{2}\");\nexports.unicode2Pattern = unicode2Pattern;\n\nvar unicode4Pattern = rePattern(\"[0-9A-Fa-f]{4}\");\nexports.unicode4Pattern = unicode4Pattern;\n\nvar validateUnicodeEscape = function validateUnicodeEscape(unicodePattern, reader, escapeChar, unicodeStr) {\n  return reMatches(unicodePattern, unicodeStr) ?\n    unicodeStr :\n    readerError(reader, \"\" + \"Unexpected unicode escape \" + \"\\\\\" + escapeChar + unicodeStr);\n};\nexports.validateUnicodeEscape = validateUnicodeEscape;\n\nvar makeUnicodeChar = function makeUnicodeChar(codeStr, base) {\n  var base = base || 16;\n  var code = parseInt(codeStr, base);\n  return char(code);\n};\nexports.makeUnicodeChar = makeUnicodeChar;\n\nvar escapeChar = function escapeChar(buffer, reader) {\n  var ch = readChar(reader);\n  var mapresult = escapeCharMap(ch);\n  return mapresult ?\n    mapresult :\n  ch === \"x\" ?\n    makeUnicodeChar(validateUnicodeEscape(unicode2Pattern, reader, ch, read2Chars(reader))) :\n  ch === \"u\" ?\n    makeUnicodeChar(validateUnicodeEscape(unicode4Pattern, reader, ch, read4Chars(reader))) :\n  isNumeric(ch) ?\n    char(ch) :\n  \"else\" ?\n    readerError(reader, \"\" + \"Unexpected unicode escape \" + \"\\\\\" + ch) :\n    void(0);\n};\nexports.escapeChar = escapeChar;\n\nvar readPast = function readPast(predicate, reader) {\n  return (function loop(_) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = predicate(peekChar(reader)) ?\n      (_ = readChar(reader), loop) :\n      peekChar(reader);\n    };\n    return recur;\n  })(void(0));\n};\nexports.readPast = readPast;\n\nvar readDelimitedList = function readDelimitedList(delim, reader, isRecursive) {\n  return (function loop(form) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readPast(isWhitespace, reader);\n      !(ch) ?\n        readerError(reader, \"EOF\") :\n        void(0);\n      return delim === ch ?\n        (function() {\n          readChar(reader);\n          return form;\n        })() :\n        (function() {\n          var macro = macros(ch);\n          return macro ?\n            (function() {\n              var result = macro(reader, readChar(reader));\n              return (form = result === reader ?\n                form :\n                conj(form, result), loop);\n            })() :\n            (function() {\n              var o = read(reader, true, void(0), isRecursive);\n              return (form = o === reader ?\n                form :\n                conj(form, o), loop);\n            })();\n        })();\n    })();\n    };\n    return recur;\n  })([]);\n};\nexports.readDelimitedList = readDelimitedList;\n\nvar notImplemented = function notImplemented(reader, ch) {\n  return readerError(reader, \"\" + \"Reader for \" + ch + \" not implemented yet\");\n};\nexports.notImplemented = notImplemented;\n\nvar readDispatch = function readDispatch(reader, _) {\n  var ch = readChar(reader);\n  var dm = dispatchMacros(ch);\n  return dm ?\n    dm(reader, _) :\n    (function() {\n      var object = maybeReadTaggedType(reader, ch);\n      return object ?\n        object :\n        readerError(reader, \"No dispatch macro for \", ch);\n    })();\n};\nexports.readDispatch = readDispatch;\n\nvar readUnmatchedDelimiter = function readUnmatchedDelimiter(rdr, ch) {\n  return readerError(rdr, \"Unmached delimiter \", ch);\n};\nexports.readUnmatchedDelimiter = readUnmatchedDelimiter;\n\nvar readList = function readList(reader, _) {\n  var form = readDelimitedList(\")\", reader, true);\n  return withMeta(list.apply(list, form), meta(form));\n};\nexports.readList = readList;\n\nvar readComment = function readComment(reader, _) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (\"\\n\" === ch) ?\n      reader || (list(symbol(void(0), \"comment\"), buffer)) :\n    (\"\\\\\" === ch) ?\n      (buffer = \"\" + buffer + (escapeChar(buffer, reader)), ch = readChar(reader), loop) :\n    \"else\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readComment = readComment;\n\nvar readVector = function readVector(reader) {\n  return readDelimitedList(\"]\", reader, true);\n};\nexports.readVector = readVector;\n\nvar readMap = function readMap(reader) {\n  var form = readDelimitedList(\"}\", reader, true);\n  return isOdd(count(form)) ?\n    readerError(reader, \"Map literal must contain an even number of forms\") :\n    withMeta(dictionary.apply(dictionary, form), meta(form));\n};\nexports.readMap = readMap;\n\nvar readSet = function readSet(reader, _) {\n  var form = readDelimitedList(\"}\", reader, true);\n  return withMeta(concat([symbol(void(0), \"set\")], form), meta(form));\n};\nexports.readSet = readSet;\n\nvar readNumber = function readNumber(reader, initch) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (isNil(ch)) || (isWhitespace(ch)) || (macros(ch)) ?\n      (function() {\n        var match = matchNumber(buffer);\n        return isNil(match) ?\n          readerError(reader, \"Invalid number format [\", buffer, \"]\") :\n          match;\n      })() :\n      (buffer = \"\" + buffer + (readChar(reader)), ch = peekChar(reader), loop);\n    };\n    return recur;\n  })(initch, peekChar(reader));\n};\nexports.readNumber = readNumber;\n\nvar readString = function readString(reader) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isNil(ch) ?\n      readerError(reader, \"EOF while reading string\") :\n    \"\\\\\" === ch ?\n      (buffer = \"\" + buffer + (escapeChar(buffer, reader)), ch = readChar(reader), loop) :\n    \"\\\"\" === ch ?\n      buffer :\n    \"default\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readString = readString;\n\nvar readUnquote = function readUnquote(reader) {\n  var ch = peekChar(reader);\n  return !(ch) ?\n    readerError(reader, \"EOF while reading character\") :\n  ch === \"@\" ?\n    (function() {\n      readChar(reader);\n      return list(symbol(void(0), \"unquote-splicing\"), read(reader, true, void(0), true));\n    })() :\n    list(symbol(void(0), \"unquote\"), read(reader, true, void(0), true));\n};\nexports.readUnquote = readUnquote;\n\nvar specialSymbols = function specialSymbols(text, notFound) {\n  return text === \"nil\" ?\n    void(0) :\n  text === \"true\" ?\n    true :\n  text === \"false\" ?\n    false :\n  \"else\" ?\n    notFound :\n    void(0);\n};\nexports.specialSymbols = specialSymbols;\n\nvar readSymbol = function readSymbol(reader, initch) {\n  var token = readToken(reader, initch);\n  var parts = split(token, \"/\");\n  var hasNs = (count(parts) > 1) && (count(token) > 1);\n  var ns = first(parts);\n  var name = join(\"/\", rest(parts));\n  return hasNs ?\n    symbol(ns, name) :\n    specialSymbols(token, symbol(token));\n};\nexports.readSymbol = readSymbol;\n\nvar readKeyword = function readKeyword(reader, initch) {\n  var token = readToken(reader, readChar(reader));\n  var parts = split(token, \"/\");\n  var name = last(parts);\n  var ns = count(parts) > 1 ?\n    join(\"/\", butlast(parts)) :\n    void(0);\n  var issue = last(ns) === \":\" ?\n    \"namespace can't ends with \\\":\\\"\" :\n  last(name) === \":\" ?\n    \"name can't end with \\\":\\\"\" :\n  last(name) === \"/\" ?\n    \"name can't end with \\\"/\\\"\" :\n  count(split(token, \"::\")) > 1 ?\n    \"name can't contain \\\"::\\\"\" :\n    void(0);\n  return issue ?\n    readerError(reader, \"Invalid token (\", issue, \"): \", token) :\n  (!(ns)) && (first(name) === \":\") ?\n    keyword(rest(name)) :\n    keyword(ns, name);\n};\nexports.readKeyword = readKeyword;\n\nvar desugarMeta = function desugarMeta(f) {\n  return isKeyword(f) ?\n    dictionary(name(f), true) :\n  isSymbol(f) ?\n    {\n      \"tag\": f\n    } :\n  isString(f) ?\n    {\n      \"tag\": f\n    } :\n  \"else\" ?\n    f :\n    void(0);\n};\nexports.desugarMeta = desugarMeta;\n\nvar wrappingReader = function wrappingReader(prefix) {\n  return function(reader) {\n    return list(prefix, read(reader, true, void(0), true));\n  };\n};\nexports.wrappingReader = wrappingReader;\n\nvar throwingReader = function throwingReader(msg) {\n  return function(reader) {\n    return readerError(reader, msg);\n  };\n};\nexports.throwingReader = throwingReader;\n\nvar readMeta = function readMeta(reader, _) {\n  var metadata = desugarMeta(read(reader, true, void(0), true));\n  !(isDictionary(metadata)) ?\n    readerError(reader, \"Metadata must be Symbol, Keyword, String or Map\") :\n    void(0);\n  return (function() {\n    var form = read(reader, true, void(0), true);\n    return isObject(form) ?\n      withMeta(form, conj(metadata, meta(form))) :\n      form;\n  })();\n};\nexports.readMeta = readMeta;\n\nvar readRegex = function readRegex(reader) {\n  return (function loop(buffer, ch) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isNil(ch) ?\n      readerError(reader, \"EOF while reading string\") :\n    \"\\\\\" === ch ?\n      (buffer = \"\" + buffer + ch + (readChar(reader)), ch = readChar(reader), loop) :\n    \"\\\"\" === ch ?\n      rePattern(buffer) :\n    \"default\" ?\n      (buffer = \"\" + buffer + ch, ch = readChar(reader), loop) :\n      void(0);\n    };\n    return recur;\n  })(\"\", readChar(reader));\n};\nexports.readRegex = readRegex;\n\nvar readParam = function readParam(reader, initch) {\n  var form = readSymbol(reader, initch);\n  return isEqual(form, symbol(\"%\")) ?\n    symbol(\"%1\") :\n    form;\n};\nexports.readParam = readParam;\n\nvar isParam = function isParam(form) {\n  return (isSymbol(form)) && (\"%\" === first(name(form)));\n};\nexports.isParam = isParam;\n\nvar lambdaParamsHash = function lambdaParamsHash(form) {\n  return isParam(form) ?\n    dictionary(form, form) :\n  (isDictionary(form)) || (isVector(form)) || (isList(form)) ?\n    conj.apply(conj, map(lambdaParamsHash, vec(form))) :\n  \"else\" ?\n    {} :\n    void(0);\n};\nexports.lambdaParamsHash = lambdaParamsHash;\n\nvar lambdaParams = function lambdaParams(body) {\n  var names = sort(vals(lambdaParamsHash(body)));\n  var variadic = isEqual(first(names), symbol(\"%&\"));\n  var n = variadic && (count(names) === 1) ?\n    0 :\n    parseInt(rest(name(last(names))));\n  var params = (function loop(names, i) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = i <= n ?\n      (names = conj(names, symbol(\"\" + \"%\" + i)), i = inc(i), loop) :\n      names;\n    };\n    return recur;\n  })([], 1);\n  return variadic ?\n    conj(params, symbol(void(0), \"&\"), symbol(void(0), \"%&\")) :\n    names;\n};\nexports.lambdaParams = lambdaParams;\n\nvar readLambda = function readLambda(reader) {\n  var body = readList(reader);\n  return list(symbol(void(0), \"fn\"), lambdaParams(body), body);\n};\nexports.readLambda = readLambda;\n\nvar readDiscard = function readDiscard(reader, _) {\n  read(reader, true, void(0), true);\n  return reader;\n};\nexports.readDiscard = readDiscard;\n\nvar macros = function macros(c) {\n  return c === \"\\\"\" ?\n    readString :\n  c === \":\" ?\n    readKeyword :\n  c === \";\" ?\n    readComment :\n  c === \"'\" ?\n    wrappingReader(symbol(void(0), \"quote\")) :\n  c === \"@\" ?\n    wrappingReader(symbol(void(0), \"deref\")) :\n  c === \"^\" ?\n    readMeta :\n  c === \"`\" ?\n    wrappingReader(symbol(void(0), \"syntax-quote\")) :\n  c === \"~\" ?\n    readUnquote :\n  c === \"(\" ?\n    readList :\n  c === \")\" ?\n    readUnmatchedDelimiter :\n  c === \"[\" ?\n    readVector :\n  c === \"]\" ?\n    readUnmatchedDelimiter :\n  c === \"{\" ?\n    readMap :\n  c === \"}\" ?\n    readUnmatchedDelimiter :\n  c === \"\\\\\" ?\n    readChar :\n  c === \"%\" ?\n    readParam :\n  c === \"#\" ?\n    readDispatch :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.macros = macros;\n\nvar dispatchMacros = function dispatchMacros(s) {\n  return s === \"{\" ?\n    readSet :\n  s === \"(\" ?\n    readLambda :\n  s === \"<\" ?\n    throwingReader(\"Unreadable form\") :\n  s === \"\\\"\" ?\n    readRegex :\n  s === \"!\" ?\n    readComment :\n  s === \"_\" ?\n    readDiscard :\n  \"else\" ?\n    void(0) :\n    void(0);\n};\nexports.dispatchMacros = dispatchMacros;\n\nvar readForm = function readForm(reader, ch) {\n  var start = {\n    \"line\": (reader || 0)[\"line\"],\n    \"column\": (reader || 0)[\"column\"]\n  };\n  var readMacro = macros(ch);\n  var form = readMacro ?\n    readMacro(reader, ch) :\n  isNumberLiteral(reader, ch) ?\n    readNumber(reader, ch) :\n  \"else\" ?\n    readSymbol(reader, ch) :\n    void(0);\n  return form === reader ?\n    form :\n  !((isString(form)) || (isNumber(form)) || (isBoolean(form)) || (isNil(form)) || (isKeyword(form))) ?\n    withMeta(form, conj({\n      \"start\": start,\n      \"end\": {\n        \"line\": (reader || 0)[\"line\"],\n        \"column\": (reader || 0)[\"column\"]\n      }\n    }, meta(form))) :\n  \"else\" ?\n    form :\n    void(0);\n};\nexports.readForm = readForm;\n\nvar read = function read(reader, eofIsError, sentinel, isRecursive) {\n  return (function loop() {\n    var recur = loop;\n    while (recur === loop) {\n      recur = (function() {\n      var ch = readChar(reader);\n      var form = isNil(ch) ?\n        eofIsError ?\n          readerError(reader, \"EOF\") :\n          sentinel :\n      isWhitespace(ch) ?\n        reader :\n      isCommentPrefix(ch) ?\n        read(readComment(reader, ch), eofIsError, sentinel, isRecursive) :\n      \"else\" ?\n        readForm(reader, ch) :\n        void(0);\n      return form === reader ?\n        (loop) :\n        form;\n    })();\n    };\n    return recur;\n  })();\n};\nexports.read = read;\n\nvar readFromString = function readFromString(source, uri) {\n  var reader = pushBackReader(source, uri);\n  return read(reader, true, void(0), false);\n};\nexports.readFromString = readFromString;\n\nvar readUuid = function readUuid(uuid) {\n  return isString(uuid) ?\n    list(symbol(void(0), \"UUID.\"), uuid) :\n    readerError(void(0), \"UUID literal expects a string as its representation.\");\n};\n\nvar readQueue = function readQueue(items) {\n  return isVector(items) ?\n    list(symbol(void(0), \"PersistentQueue.\"), items) :\n    readerError(void(0), \"Queue literal expects a vector for its elements.\");\n};\n\nvar __tagTable__ = dictionary(\"uuid\", readUuid, \"queue\", readQueue);\nexports.__tagTable__ = __tagTable__;\n\nvar maybeReadTaggedType = function maybeReadTaggedType(reader, initch) {\n  var tag = readSymbol(reader, initch);\n  var pfn = __tagTable__[name(tag)];\n  return pfn ?\n    pfn(read(reader, true, void(0), false)) :\n    readerError(reader, \"\" + \"Could not find tag parser for \" + (name(tag)) + \" in \" + (\"\" + (keys(__tagTable__))));\n};\nexports.maybeReadTaggedType = maybeReadTaggedType\n\n//@ sourceURL=/lib/reader.js"));

require.define("/lib/ast.js",Function(['require','module','exports','__dirname','__filename','process'],"var vec = (require(\"./sequence\")).vec;\nvar map = (require(\"./sequence\")).map;\nvar last = (require(\"./sequence\")).last;\nvar count = (require(\"./sequence\")).count;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar isSequential = (require(\"./sequence\")).isSequential;\nvar isList = (require(\"./sequence\")).isList;;\n\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar subs = (require(\"./runtime\")).subs;\nvar inc = (require(\"./runtime\")).inc;\nvar str = (require(\"./runtime\")).str;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isRePattern = (require(\"./runtime\")).isRePattern;\nvar isDate = (require(\"./runtime\")).isDate;\nvar isObject = (require(\"./runtime\")).isObject;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isString = (require(\"./runtime\")).isString;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNil = (require(\"./runtime\")).isNil;;\n\nvar withMeta = function withMeta(value, metadata) {\n  Object.defineProperty(value, \"metadata\", {\n    \"value\": metadata,\n    \"configurable\": true\n  });\n  return value;\n};\nexports.withMeta = withMeta;\n\nvar meta = function meta(value) {\n  return isObject(value) ?\n    value.metadata :\n    void(0);\n};\nexports.meta = meta;\n\nvar __nsSeparator__ = \"\";\nexports.__nsSeparator__ = __nsSeparator__;\n\nvar Symbol = function Symbol(namespace, name) {\n  this.namespace = namespace;\n  this.name = name;\n  return this;\n};\n\nSymbol.type = \"wisp.symbol\";\n\nSymbol.prototype.type = Symbol.type;\n\nSymbol.prototype.toString = function() {\n  var ns = namespace(this);\n  return ns ?\n    \"\" + ns + \"/\" + (name(this)) :\n    \"\" + (name(this));\n};\n\nvar symbol = function symbol(ns, id) {\n  return isSymbol(ns) ?\n    ns :\n  isKeyword(ns) ?\n    new Symbol(namespace(ns), name(ns)) :\n  isNil(id) ?\n    new Symbol(void(0), ns) :\n  \"else\" ?\n    new Symbol(ns, id) :\n    void(0);\n};\nexports.symbol = symbol;\n\nvar isSymbol = function isSymbol(x) {\n  return x && (Symbol.type === x.type);\n};\nexports.isSymbol = isSymbol;\n\nvar isKeyword = function isKeyword(x) {\n  return (isString(x)) && (count(x) > 1) && (first(x) === \"\");\n};\nexports.isKeyword = isKeyword;\n\nvar keyword = function keyword(ns, id) {\n  return isKeyword(ns) ?\n    ns :\n  isSymbol(ns) ?\n    \"\" + \"\" + (name(ns)) :\n  isNil(id) ?\n    \"\" + \"\" + ns :\n  isNil(ns) ?\n    \"\" + \"\" + id :\n  \"else\" ?\n    \"\" + \"\" + ns + __nsSeparator__ + id :\n    void(0);\n};\nexports.keyword = keyword;\n\nvar keywordName = function keywordName(value) {\n  return last(split(subs(value, 1), __nsSeparator__));\n};\n\nvar name = function name(value) {\n  return isSymbol(value) ?\n    value.name :\n  isKeyword(value) ?\n    keywordName(value) :\n  isString(value) ?\n    value :\n  \"else\" ?\n    (function() { throw new TypeError(\"\" + \"Doesn't support name: \" + value); })() :\n    void(0);\n};\nexports.name = name;\n\nvar keywordNamespace = function keywordNamespace(x) {\n  var parts = split(subs(x, 1), __nsSeparator__);\n  return count(parts) > 1 ?\n    parts[0] :\n    void(0);\n};\n\nvar namespace = function namespace(x) {\n  return isSymbol(x) ?\n    x.namespace :\n  isKeyword(x) ?\n    keywordNamespace(x) :\n  \"else\" ?\n    (function() { throw new TypeError(\"\" + \"Doesn't supports namespace: \" + x); })() :\n    void(0);\n};\nexports.namespace = namespace;\n\nvar gensym = function gensym(prefix) {\n  return symbol(\"\" + (isNil(prefix) ?\n    \"G__\" :\n    prefix) + (gensym.base = gensym.base + 1));\n};\nexports.gensym = gensym;\n\ngensym.base = 0;\n\nvar isUnquote = function isUnquote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"unquote\")));\n};\nexports.isUnquote = isUnquote;\n\nvar isUnquoteSplicing = function isUnquoteSplicing(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"unquote-splicing\")));\n};\nexports.isUnquoteSplicing = isUnquoteSplicing;\n\nvar isQuote = function isQuote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"quote\")));\n};\nexports.isQuote = isQuote;\n\nvar isSyntaxQuote = function isSyntaxQuote(form) {\n  return (isList(form)) && (isEqual(first(form), symbol(void(0), \"syntax-quote\")));\n};\nexports.isSyntaxQuote = isSyntaxQuote;\n\nvar normalize = function normalize(n, len) {\n  return (function loop(ns) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(ns) < len ?\n      (ns = \"\" + \"0\" + ns, loop) :\n      ns;\n    };\n    return recur;\n  })(\"\" + n);\n};\n\nvar quoteString = function quoteString(s) {\n  s = join(\"\\\\\\\"\", split(s, \"\\\"\"));\n  s = join(\"\\\\\\\\\", split(s, \"\\\\\"));\n  s = join(\"\\\\b\", split(s, \"\b\"));\n  s = join(\"\\\\f\", split(s, \"\f\"));\n  s = join(\"\\\\n\", split(s, \"\\n\"));\n  s = join(\"\\\\r\", split(s, \"\\r\"));\n  s = join(\"\\\\t\", split(s, \"\\t\"));\n  return \"\" + \"\\\"\" + s + \"\\\"\";\n};\nexports.quoteString = quoteString;\n\nvar prStr = function prStr(x) {\n  return isNil(x) ?\n    \"nil\" :\n  isKeyword(x) ?\n    namespace(x) ?\n      \"\" + \":\" + (namespace(x)) + \"/\" + (name(x)) :\n      \"\" + \":\" + (name(x)) :\n  isString(x) ?\n    quoteString(x) :\n  isDate(x) ?\n    \"\" + \"#inst \\\"\" + (x.getUTCFullYear()) + \"-\" + (normalize(inc(x.getUTCMonth()), 2)) + \"-\" + (normalize(x.getUTCDate(), 2)) + \"T\" + (normalize(x.getUTCHours(), 2)) + \":\" + (normalize(x.getUTCMinutes(), 2)) + \":\" + (normalize(x.getUTCSeconds(), 2)) + \".\" + (normalize(x.getUTCMilliseconds(), 3)) + \"-\" + \"00:00\\\"\" :\n  isVector(x) ?\n    \"\" + \"[\" + (join(\" \", map(prStr, vec(x)))) + \"]\" :\n  isDictionary(x) ?\n    \"\" + \"{\" + (join(\", \", map(function(pair) {\n      return \"\" + (prStr(first(pair))) + \" \" + (prStr(second(pair)));\n    }, x))) + \"}\" :\n  isSequential(x) ?\n    \"\" + \"(\" + (join(\" \", map(prStr, vec(x)))) + \")\" :\n  isRePattern(x) ?\n    \"\" + \"#\\\"\" + (join(\"\\\\/\", split(x.source, \"/\"))) + \"\\\"\" :\n  \"else\" ?\n    \"\" + x :\n    void(0);\n};\nexports.prStr = prStr\n\n//@ sourceURL=/lib/ast.js"));

require.define("/lib/string.js",Function(['require','module','exports','__dirname','__filename','process'],"var isString = (require(\"./runtime\")).isString;\nvar isNil = (require(\"./runtime\")).isNil;\nvar reMatches = (require(\"./runtime\")).reMatches;\nvar subs = (require(\"./runtime\")).subs;\nvar str = (require(\"./runtime\")).str;;\n\nvar isEmpty = (require(\"./sequence\")).isEmpty;\nvar vec = (require(\"./sequence\")).vec;;\n\nvar split = function split(string, pattern, limit) {\n  return string.split(pattern, limit);\n};\nexports.split = split;\n\nvar join = function join(separator, coll) {\n  switch (arguments.length) {\n    case 1:\n      var coll = separator;\n      return str.apply(str, vec(coll));\n    case 2:\n      return vec(coll).join(separator);\n    \n    default:\n      (function() { throw Error(\"Invalid arity\"); })()\n  };\n  return void(0);\n};\nexports.join = join;\n\nvar upperCase = function upperCase(string) {\n  return string.toUpperCase();\n};\nexports.upperCase = upperCase;\n\nvar upperCase = function upperCase(string) {\n  return string.toUpperCase();\n};\nexports.upperCase = upperCase;\n\nvar lowerCase = function lowerCase(string) {\n  return string.toLowerCase();\n};\nexports.lowerCase = lowerCase;\n\nvar capitalize = function capitalize(string) {\n  return count(string) < 2 ?\n    upperCase(string) :\n    \"\" + (upperCase(subs(s, 0, 1))) + (lowerCase(subs(s, 1)));\n};\nexports.capitalize = capitalize;\n\nvar replace = function replace(string, match, replacement) {\n  return string.replace(match, replacement);\n};\nexports.replace = replace;\n\nvar __LEFTSPACES__ = /^\\s\\s*/;\nexports.__LEFTSPACES__ = __LEFTSPACES__;\n\nvar __RIGHTSPACES__ = /\\s\\s*$/;\nexports.__RIGHTSPACES__ = __RIGHTSPACES__;\n\nvar __SPACES__ = /^\\s\\s*$/;\nexports.__SPACES__ = __SPACES__;\n\nvar triml = isNil(\"\".trimLeft) ?\n  function(string) {\n    return string.replace(__LEFTSPACES__, \"\");\n  } :\n  function triml(string) {\n    return string.trimLeft();\n  };\nexports.triml = triml;\n\nvar trimr = isNil(\"\".trimRight) ?\n  function(string) {\n    return string.replace(__RIGHTSPACES__, \"\");\n  } :\n  function trimr(string) {\n    return string.trimRight();\n  };\nexports.trimr = trimr;\n\nvar trim = isNil(\"\".trim) ?\n  function(string) {\n    return string.replace(__LEFTSPACES__).replace(__RIGHTSPACES__);\n  } :\n  function trim(string) {\n    return string.trim();\n  };\nexports.trim = trim;\n\nvar isBlank = function isBlank(string) {\n  return (isNil(string)) || (isEmpty(string)) || (reMatches(__SPACES__, string));\n};\nexports.isBlank = isBlank\n\n//@ sourceURL=/lib/string.js"));

require.define("/lib/compiler.js",Function(['require','module','exports','__dirname','__filename','process'],"var readFromString = (require(\"./reader\")).readFromString;;\n\nvar prStr = (require(\"./ast\")).prStr;\nvar gensym = (require(\"./ast\")).gensym;\nvar name = (require(\"./ast\")).name;\nvar isSyntaxQuote = (require(\"./ast\")).isSyntaxQuote;\nvar isQuote = (require(\"./ast\")).isQuote;\nvar isUnquoteSplicing = (require(\"./ast\")).isUnquoteSplicing;\nvar isUnquote = (require(\"./ast\")).isUnquote;\nvar namespace = (require(\"./ast\")).namespace;\nvar keyword = (require(\"./ast\")).keyword;\nvar isKeyword = (require(\"./ast\")).isKeyword;\nvar symbol = (require(\"./ast\")).symbol;\nvar isSymbol = (require(\"./ast\")).isSymbol;\nvar withMeta = (require(\"./ast\")).withMeta;\nvar meta = (require(\"./ast\")).meta;;\n\nvar concat = (require(\"./sequence\")).concat;\nvar take = (require(\"./sequence\")).take;\nvar filter = (require(\"./sequence\")).filter;\nvar map = (require(\"./sequence\")).map;\nvar last = (require(\"./sequence\")).last;\nvar vec = (require(\"./sequence\")).vec;\nvar reduce = (require(\"./sequence\")).reduce;\nvar reverse = (require(\"./sequence\")).reverse;\nvar conj = (require(\"./sequence\")).conj;\nvar cons = (require(\"./sequence\")).cons;\nvar rest = (require(\"./sequence\")).rest;\nvar third = (require(\"./sequence\")).third;\nvar second = (require(\"./sequence\")).second;\nvar first = (require(\"./sequence\")).first;\nvar list = (require(\"./sequence\")).list;\nvar isList = (require(\"./sequence\")).isList;\nvar count = (require(\"./sequence\")).count;\nvar isEmpty = (require(\"./sequence\")).isEmpty;;\n\nvar isStrictEqual = (require(\"./runtime\")).isStrictEqual;\nvar isEqual = (require(\"./runtime\")).isEqual;\nvar int = (require(\"./runtime\")).int;\nvar char = (require(\"./runtime\")).char;\nvar str = (require(\"./runtime\")).str;\nvar dec = (require(\"./runtime\")).dec;\nvar inc = (require(\"./runtime\")).inc;\nvar isRePattern = (require(\"./runtime\")).isRePattern;\nvar isNil = (require(\"./runtime\")).isNil;\nvar isFalse = (require(\"./runtime\")).isFalse;\nvar isTrue = (require(\"./runtime\")).isTrue;\nvar reFind = (require(\"./runtime\")).reFind;\nvar subs = (require(\"./runtime\")).subs;\nvar isBoolean = (require(\"./runtime\")).isBoolean;\nvar isVector = (require(\"./runtime\")).isVector;\nvar isNumber = (require(\"./runtime\")).isNumber;\nvar isString = (require(\"./runtime\")).isString;\nvar mapDictionary = (require(\"./runtime\")).mapDictionary;\nvar isContainsVector = (require(\"./runtime\")).isContainsVector;\nvar vals = (require(\"./runtime\")).vals;\nvar keys = (require(\"./runtime\")).keys;\nvar merge = (require(\"./runtime\")).merge;\nvar dictionary = (require(\"./runtime\")).dictionary;\nvar isDictionary = (require(\"./runtime\")).isDictionary;\nvar isOdd = (require(\"./runtime\")).isOdd;;\n\nvar replace = (require(\"./string\")).replace;\nvar upperCase = (require(\"./string\")).upperCase;\nvar join = (require(\"./string\")).join;\nvar split = (require(\"./string\")).split;;\n\nvar isSelfEvaluating = function isSelfEvaluating(form) {\n  return (isNumber(form)) || ((isString(form)) && (!(isSymbol(form))) && (!(isKeyword(form)))) || (isBoolean(form)) || (isNil(form)) || (isRePattern(form));\n};\nexports.isSelfEvaluating = isSelfEvaluating;\n\nvar __macros__ = {};\nexports.__macros__ = __macros__;\n\nvar executeMacro = function executeMacro(name, form) {\n  return __macros__[name].apply(__macros__[name], vec(form));\n};\nexports.executeMacro = executeMacro;\n\nvar installMacro = function installMacro(name, macroFn) {\n  return __macros__[name] = macroFn;\n};\nexports.installMacro = installMacro;\n\nvar isMacro = function isMacro(name) {\n  return (isSymbol(name)) && (__macros__[name]) && true;\n};\nexports.isMacro = isMacro;\n\nvar makeMacro = function makeMacro(pattern, body) {\n  var macroFn = concat(list(symbol(void(0), \"fn\"), pattern), body);\n  return eval(\"\" + \"(\" + (compile(macroexpand(macroFn))) + \")\");\n};\nexports.makeMacro = makeMacro;\n\ninstallMacro(symbol(void(0), \"defmacro\"), function(name, signature) {\n  var body = Array.prototype.slice.call(arguments, 2);\n  return installMacro(name, makeMacro(signature, body));\n});\n\nvar __specials__ = {};\nexports.__specials__ = __specials__;\n\nvar installSpecial = function installSpecial(name, f, validator) {\n  return __specials__[name] = function(form) {\n    validator ?\n      validator(form) :\n      void(0);\n    return f(withMeta(rest(form), meta(form)));\n  };\n};\nexports.installSpecial = installSpecial;\n\nvar isSpecial = function isSpecial(name) {\n  return (isSymbol(name)) && (__specials__[name]) && true;\n};\nexports.isSpecial = isSpecial;\n\nvar executeSpecial = function executeSpecial(name, form) {\n  return (__specials__[name])(form);\n};\nexports.executeSpecial = executeSpecial;\n\nvar opt = function opt(argument, fallback) {\n  return (isNil(argument)) || (isEmpty(argument)) ?\n    fallback :\n    first(argument);\n};\nexports.opt = opt;\n\nvar applyForm = function applyForm(fnName, form, isQuoted) {\n  return cons(fnName, isQuoted ?\n    map(function(e) {\n      return list(symbol(void(0), \"quote\"), e);\n    }, form) :\n    form, form);\n};\nexports.applyForm = applyForm;\n\nvar applyUnquotedForm = function applyUnquotedForm(fnName, form) {\n  return cons(fnName, map(function(e) {\n    return isUnquote(e) ?\n      second(e) :\n    (isList(e)) && (isKeyword(first(e))) ?\n      list(symbol(void(0), \"syntax-quote\"), second(e)) :\n      list(symbol(void(0), \"syntax-quote\"), e);\n  }, form));\n};\nexports.applyUnquotedForm = applyUnquotedForm;\n\nvar splitSplices = function splitSplices(form, fnName) {\n  var makeSplice = function makeSplice(form) {\n    return (isSelfEvaluating(form)) || (isSymbol(form)) ?\n      applyUnquotedForm(fnName, list(form)) :\n      applyUnquotedForm(fnName, form);\n  };\n  return (function loop(nodes, slices, acc) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(nodes) ?\n      reverse(isEmpty(acc) ?\n        slices :\n        cons(makeSplice(reverse(acc)), slices)) :\n      (function() {\n        var node = first(nodes);\n        return isUnquoteSplicing(node) ?\n          (nodes = rest(nodes), slices = cons(second(node), isEmpty(acc) ?\n            slices :\n            cons(makeSplice(reverse(acc)), slices)), acc = list(), loop) :\n          (nodes = rest(nodes), slices = slices, acc = cons(node, acc), loop);\n      })();\n    };\n    return recur;\n  })(form, list(), list());\n};\nexports.splitSplices = splitSplices;\n\nvar syntaxQuoteSplit = function syntaxQuoteSplit(appendName, fnName, form) {\n  var slices = splitSplices(form, fnName);\n  var n = count(slices);\n  return n === 0 ?\n    list(fnName) :\n  n === 1 ?\n    first(slices) :\n  \"default\" ?\n    applyForm(appendName, slices) :\n    void(0);\n};\nexports.syntaxQuoteSplit = syntaxQuoteSplit;\n\nvar compileObject = function compileObject(form, isQuoted) {\n  return isKeyword(form) ?\n    compileKeyword(form) :\n  isSymbol(form) ?\n    compileSymbol(form) :\n  isNumber(form) ?\n    compileNumber(form) :\n  isString(form) ?\n    compileString(form) :\n  isBoolean(form) ?\n    compileBoolean(form) :\n  isNil(form) ?\n    compileNil(form) :\n  isRePattern(form) ?\n    compileRePattern(form) :\n  isVector(form) ?\n    compile(applyForm(symbol(void(0), \"vector\"), list.apply(list, form), isQuoted)) :\n  isList(form) ?\n    compile(applyForm(symbol(void(0), \"list\"), form, isQuoted)) :\n  isDictionary(form) ?\n    compileDictionary(isQuoted ?\n      mapDictionary(form, function(x) {\n        return list(symbol(void(0), \"quote\"), x);\n      }) :\n      form) :\n    void(0);\n};\nexports.compileObject = compileObject;\n\nvar compileReference = function compileReference(form) {\n  var id = name(form);\n  id = id === \"*\" ?\n    \"multiply\" :\n  id === \"/\" ?\n    \"divide\" :\n  id === \"+\" ?\n    \"sum\" :\n  id === \"-\" ?\n    \"subtract\" :\n  id === \"=\" ?\n    \"equal?\" :\n  id === \"==\" ?\n    \"strict-equal?\" :\n  id === \"<=\" ?\n    \"not-greater-than\" :\n  id === \">=\" ?\n    \"not-less-than\" :\n  id === \">\" ?\n    \"greater-than\" :\n  id === \"<\" ?\n    \"less-than\" :\n  \"else\" ?\n    id :\n    void(0);\n  id = join(\"_\", split(id, \"*\"));\n  id = join(\"-to-\", split(id, \"->\"));\n  id = join(split(id, \"!\"));\n  id = join(\"$\", split(id, \"%\"));\n  id = join(\"-plus-\", split(id, \"+\"));\n  id = join(\"-and-\", split(id, \"&\"));\n  id = last(id) === \"?\" ?\n    \"\" + \"is-\" + (subs(id, 0, dec(count(id)))) :\n    id;\n  id = reduce(function(result, key) {\n    return \"\" + result + ((!(isEmpty(result))) && (!(isEmpty(key))) ?\n      \"\" + (upperCase(key[0])) + (subs(key, 1)) :\n      key);\n  }, \"\", split(id, \"-\"));\n  return id;\n};\nexports.compileReference = compileReference;\n\nvar compileKeywordReference = function compileKeywordReference(form) {\n  return \"\" + \"\\\"\" + (name(form)) + \"\\\"\";\n};\nexports.compileKeywordReference = compileKeywordReference;\n\nvar compileSyntaxQuotedVector = function compileSyntaxQuotedVector(form) {\n  var concatForm = syntaxQuoteSplit(symbol(void(0), \"concat\"), symbol(void(0), \"vector\"), list.apply(list, form));\n  return compile(count(concatForm) > 1 ?\n    list(symbol(void(0), \"vec\"), concatForm) :\n    concatForm);\n};\nexports.compileSyntaxQuotedVector = compileSyntaxQuotedVector;\n\nvar compileSyntaxQuoted = function compileSyntaxQuoted(form) {\n  return isList(form) ?\n    compile(syntaxQuoteSplit(symbol(void(0), \"concat\"), symbol(void(0), \"list\"), form)) :\n  isVector(form) ?\n    compileSyntaxQuotedVector(form) :\n  \"else\" ?\n    compileObject(form) :\n    void(0);\n};\nexports.compileSyntaxQuoted = compileSyntaxQuoted;\n\nvar compile = function compile(form) {\n  return isSelfEvaluating(form) ?\n    compileObject(form) :\n  isSymbol(form) ?\n    compileReference(form) :\n  isKeyword(form) ?\n    compileKeywordReference(form) :\n  isVector(form) ?\n    compileObject(form) :\n  isDictionary(form) ?\n    compileObject(form) :\n  isList(form) ?\n    (function() {\n      var head = first(form);\n      return isEmpty(form) ?\n        compileObject(form, true) :\n      isQuote(form) ?\n        compileObject(second(form), true) :\n      isSyntaxQuote(form) ?\n        compileSyntaxQuoted(second(form)) :\n      isSpecial(head) ?\n        executeSpecial(head, form) :\n      isKeyword(head) ?\n        compile(list(symbol(void(0), \"get\"), list(symbol(void(0), \"or\"), second(form), 0), head)) :\n      \"else\" ?\n        (function() {\n          return !((isSymbol(head)) || (isList(head))) ?\n            (function() { throw compilerError(form, \"\" + \"operator is not a procedure: \" + head); })() :\n            compileInvoke(form);\n        })() :\n        void(0);\n    })() :\n    void(0);\n};\nexports.compile = compile;\n\nvar compileProgram = function compileProgram(forms) {\n  return (function loop(result, expressions) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(expressions) ?\n      join(\";\\n\\n\", result) :\n      (function() {\n        var expression = first(expressions);\n        var form = macroexpand(expression);\n        var expanded = isList(form) ?\n          withMeta(form, conj({\n            \"top\": true\n          }, meta(form))) :\n          form;\n        return (result = conj(result, compile(expanded)), expressions = rest(expressions), loop);\n      })();\n    };\n    return recur;\n  })([], forms);\n};\nexports.compileProgram = compileProgram;\n\nvar macroexpand1 = function macroexpand1(form) {\n  return isList(form) ?\n    (function() {\n      var op = first(form);\n      var id = isSymbol(op) ?\n        name(op) :\n        void(0);\n      return isSpecial(op) ?\n        form :\n      isMacro(op) ?\n        executeMacro(op, rest(form)) :\n      (isSymbol(op)) && (!(id === \".\")) ?\n        first(id) === \".\" ?\n          count(form) < 2 ?\n            (function() { throw Error(\"Malformed member expression, expecting (.member target ...)\"); })() :\n            cons(symbol(void(0), \".\"), cons(second(form), cons(symbol(subs(id, 1)), rest(rest(form))))) :\n        last(id) === \".\" ?\n          cons(symbol(void(0), \"new\"), cons(symbol(subs(id, 0, dec(count(id)))), rest(form))) :\n          form :\n      \"else\" ?\n        form :\n        void(0);\n    })() :\n    form;\n};\nexports.macroexpand1 = macroexpand1;\n\nvar macroexpand = function macroexpand(form) {\n  return (function loop(original, expanded) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = original === expanded ?\n      original :\n      (original = expanded, expanded = macroexpand1(expanded), loop);\n    };\n    return recur;\n  })(form, macroexpand1(form));\n};\nexports.macroexpand = macroexpand;\n\nvar compileTemplate = function compileTemplate(form) {\n  var indentPattern = /\\n *$/;\n  var lineBreakPatter = RegExp(\"\\n\", \"g\");\n  var getIndentation = function(code) {\n    return (reFind(indentPattern, code)) || \"\\n\";\n  };\n  return (function loop(code, parts, values) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(parts) > 1 ?\n      (code = \"\" + code + (first(parts)) + (replace(\"\" + \"\" + (first(values)), lineBreakPatter, getIndentation(first(parts)))), parts = rest(parts), values = rest(values), loop) :\n      \"\" + code + (first(parts));\n    };\n    return recur;\n  })(\"\", split(first(form), \"~{}\"), rest(form));\n};\nexports.compileTemplate = compileTemplate;\n\nvar compileComment = function compileComment(form) {\n  return compileTemplate(list(\"//~{}\\n\", first(form)));\n};\nexports.compileComment = compileComment;\n\nvar compileDef = function compileDef(form) {\n  var id = first(form);\n  var isExport = ((((meta(form)) || {}) || 0)[\"top\"]) && (!((((meta(id)) || {}) || 0)[\"private\"]));\n  var attribute = symbol(namespace(id), \"\" + \"-\" + (name(id)));\n  return isExport ?\n    compileTemplate(list(\"var ~{};\\n~{}\", compile(cons(symbol(void(0), \"set!\"), form)), compile(list(symbol(void(0), \"set!\"), list(symbol(void(0), \".\"), symbol(void(0), \"exports\"), attribute), id)))) :\n    compileTemplate(list(\"var ~{}\", compile(cons(symbol(void(0), \"set!\"), form))));\n};\nexports.compileDef = compileDef;\n\nvar compileIfElse = function compileIfElse(form) {\n  var condition = macroexpand(first(form));\n  var thenExpression = macroexpand(second(form));\n  var elseExpression = macroexpand(third(form));\n  return compileTemplate(list((isList(elseExpression)) && (isEqual(first(elseExpression), symbol(void(0), \"if\"))) ?\n    \"~{} ?\\n  ~{} :\\n~{}\" :\n    \"~{} ?\\n  ~{} :\\n  ~{}\", compile(condition), compile(thenExpression), compile(elseExpression)));\n};\nexports.compileIfElse = compileIfElse;\n\nvar compileDictionary = function compileDictionary(form) {\n  var body = (function loop(body, names) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      body :\n      (body = \"\" + (isNil(body) ?\n        \"\" :\n        \"\" + body + \",\\n\") + (compileTemplate(list(\"~{}: ~{}\", compile(first(names)), compile(macroexpand(form[first(names)]))))), names = rest(names), loop);\n    };\n    return recur;\n  })(void(0), keys(form));\n  return isNil(body) ?\n    \"{}\" :\n    compileTemplate(list(\"{\\n  ~{}\\n}\", body));\n};\nexports.compileDictionary = compileDictionary;\n\nvar desugarFnName = function desugarFnName(form) {\n  return (isSymbol(first(form))) || (isNil(first(form))) ?\n    form :\n    cons(void(0), form);\n};\nexports.desugarFnName = desugarFnName;\n\nvar desugarFnDoc = function desugarFnDoc(form) {\n  return (isString(second(form))) || (isNil(second(form))) ?\n    form :\n    cons(first(form), cons(void(0), rest(form)));\n};\nexports.desugarFnDoc = desugarFnDoc;\n\nvar desugarFnAttrs = function desugarFnAttrs(form) {\n  return (isDictionary(third(form))) || (isNil(third(form))) ?\n    form :\n    cons(first(form), cons(second(form), cons(void(0), rest(rest(form)))));\n};\nexports.desugarFnAttrs = desugarFnAttrs;\n\nvar compileDesugaredFn = function compileDesugaredFn(name, doc, attrs, params, body) {\n  return compileTemplate(isNil(name) ?\n    list(\"function(~{}) {\\n  ~{}\\n}\", join(\", \", map(compile, (params || 0)[\"names\"])), compileFnBody(map(macroexpand, body), params)) :\n    list(\"function ~{}(~{}) {\\n  ~{}\\n}\", compile(name), join(\", \", map(compile, (params || 0)[\"names\"])), compileFnBody(map(macroexpand, body), params)));\n};\nexports.compileDesugaredFn = compileDesugaredFn;\n\nvar compileStatements = function compileStatements(form, prefix) {\n  return (function loop(result, expression, expressions) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(expressions) ?\n      \"\" + result + (isNil(prefix) ?\n        \"\" :\n        prefix) + (compile(macroexpand(expression))) + \";\" :\n      (result = \"\" + result + (compile(macroexpand(expression))) + \";\\n\", expression = first(expressions), expressions = rest(expressions), loop);\n    };\n    return recur;\n  })(\"\", first(form), rest(form));\n};\nexports.compileStatements = compileStatements;\n\nvar compileFnBody = function compileFnBody(form, params) {\n  return (isDictionary(params)) && ((params || 0)[\"rest\"]) ?\n    compileStatements(cons(list(symbol(void(0), \"def\"), (params || 0)[\"rest\"], list(symbol(void(0), \"Array.prototype.slice.call\"), symbol(void(0), \"arguments\"), (params || 0)[\"arity\"])), form), \"return \") :\n  (count(form) === 1) && (isList(first(form))) && (isEqual(first(first(form)), symbol(void(0), \"do\"))) ?\n    compileFnBody(rest(first(form)), params) :\n    compileStatements(form, \"return \");\n};\nexports.compileFnBody = compileFnBody;\n\nvar desugarParams = function desugarParams(params) {\n  return (function loop(names, params) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(params) ?\n      {\n        \"names\": names,\n        \"arity\": count(names),\n        \"rest\": void(0)\n      } :\n    isEqual(first(params), symbol(void(0), \"&\")) ?\n      isEqual(count(params), 1) ?\n        {\n          \"names\": names,\n          \"arity\": count(names),\n          \"rest\": void(0)\n        } :\n      isEqual(count(params), 2) ?\n        {\n          \"names\": names,\n          \"arity\": count(names),\n          \"rest\": second(params)\n        } :\n      \"else\" ?\n        (function() { throw TypeError(\"Unexpected number of parameters after &\"); })() :\n        void(0) :\n    \"else\" ?\n      (names = conj(names, first(params)), params = rest(params), loop) :\n      void(0);\n    };\n    return recur;\n  })([], params);\n};\nexports.desugarParams = desugarParams;\n\nvar analyzeOverloadedFn = function analyzeOverloadedFn(name, doc, attrs, overloads) {\n  return map(function(overload) {\n    var params = desugarParams(first(overload));\n    return {\n      \"rest\": (params || 0)[\"rest\"],\n      \"names\": (params || 0)[\"names\"],\n      \"arity\": (params || 0)[\"arity\"],\n      \"body\": rest(overload)\n    };\n  }, overloads);\n};\nexports.analyzeOverloadedFn = analyzeOverloadedFn;\n\nvar compileOverloadedFn = function compileOverloadedFn(name, doc, attrs, overloads) {\n  var methods = analyzeOverloadedFn(name, doc, attrs, overloads);\n  var fixedMethods = filter(function(method) {\n    return !((method || 0)[\"rest\"]);\n  }, methods);\n  var variadic = first(filter(function(method) {\n    return (method || 0)[\"rest\"];\n  }, methods));\n  var names = reduce(function(names, params) {\n    return count(names) > (params || 0)[\"arity\"] ?\n      names :\n      (params || 0)[\"names\"];\n  }, [], methods);\n  return list(symbol(void(0), \"fn\"), name, doc, attrs, names, list(symbol(void(0), \"raw*\"), compileSwitch(symbol(void(0), \"arguments.length\"), map(function(method) {\n    return cons((method || 0)[\"arity\"], list(symbol(void(0), \"raw*\"), compileFnBody(concat(compileRebind(names, (method || 0)[\"names\"]), (method || 0)[\"body\"]))));\n  }, fixedMethods), isNil(variadic) ?\n    list(symbol(void(0), \"throw\"), list(symbol(void(0), \"Error\"), \"Invalid arity\")) :\n    list(symbol(void(0), \"raw*\"), compileFnBody(concat(compileRebind(cons(list(symbol(void(0), \"Array.prototype.slice.call\"), symbol(void(0), \"arguments\"), (variadic || 0)[\"arity\"]), names), cons((variadic || 0)[\"rest\"], (variadic || 0)[\"names\"])), (variadic || 0)[\"body\"]))))), void(0));\n};\nexports.compileOverloadedFn = compileOverloadedFn;\n\nvar compileRebind = function compileRebind(bindings, names) {\n  return (function loop(form, bindings, names) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      reverse(form) :\n      (form = isEqual(first(names), first(bindings)) ?\n        form :\n        cons(list(symbol(void(0), \"def\"), first(names), first(bindings)), form), bindings = rest(bindings), names = rest(names), loop);\n    };\n    return recur;\n  })(list(), bindings, names);\n};\nexports.compileRebind = compileRebind;\n\nvar compileSwitchCases = function compileSwitchCases(cases) {\n  return reduce(function(form, caseExpression) {\n    return \"\" + form + (compileTemplate(list(\"case ~{}:\\n  ~{}\\n\", compile(macroexpand(first(caseExpression))), compile(macroexpand(rest(caseExpression))))));\n  }, \"\", cases);\n};\nexports.compileSwitchCases = compileSwitchCases;\n\nvar compileSwitch = function compileSwitch(value, cases, defaultCase) {\n  return compileTemplate(list(\"switch (~{}) {\\n  ~{}\\n  default:\\n    ~{}\\n}\", compile(macroexpand(value)), compileSwitchCases(cases), compile(macroexpand(defaultCase))));\n};\nexports.compileSwitch = compileSwitch;\n\nvar compileFn = function compileFn(form) {\n  var signature = desugarFnAttrs(desugarFnDoc(desugarFnName(form)));\n  var name = first(signature);\n  var doc = second(signature);\n  var attrs = third(signature);\n  return isVector(third(rest(signature))) ?\n    compileDesugaredFn(name, doc, attrs, desugarParams(third(rest(signature))), rest(rest(rest(rest(signature))))) :\n    compile(compileOverloadedFn(name, doc, attrs, rest(rest(rest(signature)))));\n};\nexports.compileFn = compileFn;\n\nvar compileInvoke = function compileInvoke(form) {\n  return compileTemplate(list(isList(first(form)) ?\n    \"(~{})(~{})\" :\n    \"~{}(~{})\", compile(first(form)), compileGroup(rest(form))));\n};\nexports.compileInvoke = compileInvoke;\n\nvar compileGroup = function compileGroup(form, wrap) {\n  return wrap ?\n    \"\" + \"(\" + (compileGroup(form)) + \")\" :\n    join(\", \", vec(map(compile, map(macroexpand, form))));\n};\nexports.compileGroup = compileGroup;\n\nvar compileDo = function compileDo(form) {\n  return compile(list(cons(symbol(void(0), \"fn\"), cons([], form))));\n};\nexports.compileDo = compileDo;\n\nvar defineBindings = function defineBindings(form) {\n  return (function loop(defs, bindings) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = count(bindings) === 0 ?\n      reverse(defs) :\n      (defs = cons(list(symbol(void(0), \"def\"), bindings[0], bindings[1]), defs), bindings = rest(rest(bindings)), loop);\n    };\n    return recur;\n  })(list(), form);\n};\nexports.defineBindings = defineBindings;\n\nvar compileThrow = function compileThrow(form) {\n  return compileTemplate(list(\"(function() { throw ~{}; })()\", compile(macroexpand(first(form)))));\n};\nexports.compileThrow = compileThrow;\n\nvar compileSet = function compileSet(form) {\n  return compileTemplate(list(\"~{} = ~{}\", compile(macroexpand(first(form))), compile(macroexpand(second(form)))));\n};\nexports.compileSet = compileSet;\n\nvar compileVector = function compileVector(form) {\n  return compileTemplate(list(\"[~{}]\", compileGroup(form)));\n};\nexports.compileVector = compileVector;\n\nvar compileTry = function compileTry(form) {\n  return (function loop(tryExprs, catchExprs, finallyExprs, exprs) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(exprs) ?\n      isEmpty(catchExprs) ?\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} finally {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compileFnBody(finallyExprs))) :\n      isEmpty(finallyExprs) ?\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} catch (~{}) {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compile(first(catchExprs)), compileFnBody(rest(catchExprs)))) :\n        compileTemplate(list(\"(function() {\\ntry {\\n  ~{}\\n} catch (~{}) {\\n  ~{}\\n} finally {\\n  ~{}\\n}})()\", compileFnBody(tryExprs), compile(first(catchExprs)), compileFnBody(rest(catchExprs)), compileFnBody(finallyExprs))) :\n    isEqual(first(first(exprs)), symbol(void(0), \"catch\")) ?\n      (tryExprs = tryExprs, catchExprs = rest(first(exprs)), finallyExprs = finallyExprs, exprs = rest(exprs), loop) :\n    isEqual(first(first(exprs)), symbol(void(0), \"finally\")) ?\n      (tryExprs = tryExprs, catchExprs = catchExprs, finallyExprs = rest(first(exprs)), exprs = rest(exprs), loop) :\n      (tryExprs = cons(first(exprs), tryExprs), catchExprs = catchExprs, finallyExprs = finallyExprs, exprs = rest(exprs), loop);\n    };\n    return recur;\n  })(list(), list(), list(), reverse(form));\n};\nexports.compileTry = compileTry;\n\nvar compileProperty = function compileProperty(form) {\n  return (name(second(form)))[0] === \"-\" ?\n    compileTemplate(list(isList(first(form)) ?\n      \"(~{}).~{}\" :\n      \"~{}.~{}\", compile(macroexpand(first(form))), compile(macroexpand(symbol(subs(name(second(form)), 1)))))) :\n    compileTemplate(list(\"~{}.~{}(~{})\", compile(macroexpand(first(form))), compile(macroexpand(second(form))), compileGroup(rest(rest(form)))));\n};\nexports.compileProperty = compileProperty;\n\nvar compileApply = function compileApply(form) {\n  return compile(list(symbol(void(0), \".\"), first(form), symbol(void(0), \"apply\"), first(form), second(form)));\n};\nexports.compileApply = compileApply;\n\nvar compileNew = function compileNew(form) {\n  return compileTemplate(list(\"new ~{}\", compile(form)));\n};\nexports.compileNew = compileNew;\n\nvar compileCompoundAccessor = function compileCompoundAccessor(form) {\n  var target = macroexpand(first(form));\n  var attribute = macroexpand(second(form));\n  var template = isList(target) ?\n    \"(~{})[~{}]\" :\n    \"~{}[~{}]\";\n  return compileTemplate(list(template, compile(target), compile(attribute)));\n};\nexports.compileCompoundAccessor = compileCompoundAccessor;\n\nvar compileInstance = function compileInstance(form) {\n  return compileTemplate(list(\"~{} instanceof ~{}\", compile(macroexpand(second(form))), compile(macroexpand(first(form)))));\n};\nexports.compileInstance = compileInstance;\n\nvar compileNot = function compileNot(form) {\n  return compileTemplate(list(\"!(~{})\", compile(macroexpand(first(form)))));\n};\nexports.compileNot = compileNot;\n\nvar compileLoop = function compileLoop(form) {\n  var bindings = (function loop(names, values, tokens) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(tokens) ?\n      {\n        \"names\": names,\n        \"values\": values\n      } :\n      (names = conj(names, first(tokens)), values = conj(values, second(tokens)), tokens = rest(rest(tokens)), loop);\n    };\n    return recur;\n  })([], [], first(form));\n  var names = (bindings || 0)[\"names\"];\n  var values = (bindings || 0)[\"values\"];\n  var body = rest(form);\n  return compile(cons(cons(symbol(void(0), \"fn\"), cons(symbol(void(0), \"loop\"), cons(names, compileRecur(names, body)))), list.apply(list, values)));\n};\nexports.compileLoop = compileLoop;\n\nvar rebindBindings = function rebindBindings(names, values) {\n  return (function loop(result, names, values) {\n    var recur = loop;\n    while (recur === loop) {\n      recur = isEmpty(names) ?\n      reverse(result) :\n      (result = cons(list(symbol(void(0), \"set!\"), first(names), first(values)), result), names = rest(names), values = rest(values), loop);\n    };\n    return recur;\n  })(list(), names, values);\n};\nexports.rebindBindings = rebindBindings;\n\nvar expandRecur = function expandRecur(names, body) {\n  return map(function(form) {\n    return isList(form) ?\n      isEqual(first(form), symbol(void(0), \"recur\")) ?\n        list(symbol(void(0), \"raw*\"), compileGroup(concat(rebindBindings(names, rest(form)), list(symbol(void(0), \"loop\"))), true)) :\n        expandRecur(names, form) :\n      form;\n  }, body);\n};\nexports.expandRecur = expandRecur;\n\nvar compileRecur = function compileRecur(names, body) {\n  return list(list(symbol(void(0), \"raw*\"), compileTemplate(list(\"var recur = loop;\\nwhile (recur === loop) {\\n  recur = ~{}\\n}\", compileStatements(expandRecur(names, body))))), symbol(void(0), \"recur\"));\n};\nexports.compileRecur = compileRecur;\n\nvar compileRaw = function compileRaw(form) {\n  return first(form);\n};\nexports.compileRaw = compileRaw;\n\ninstallSpecial(symbol(void(0), \"set!\"), compileSet);\n\ninstallSpecial(symbol(void(0), \"get\"), compileCompoundAccessor);\n\ninstallSpecial(symbol(void(0), \"aget\"), compileCompoundAccessor);\n\ninstallSpecial(symbol(void(0), \"def\"), compileDef);\n\ninstallSpecial(symbol(void(0), \"if\"), compileIfElse);\n\ninstallSpecial(symbol(void(0), \"do\"), compileDo);\n\ninstallSpecial(symbol(void(0), \"do*\"), compileStatements);\n\ninstallSpecial(symbol(void(0), \"fn\"), compileFn);\n\ninstallSpecial(symbol(void(0), \"throw\"), compileThrow);\n\ninstallSpecial(symbol(void(0), \"vector\"), compileVector);\n\ninstallSpecial(symbol(void(0), \"try\"), compileTry);\n\ninstallSpecial(symbol(void(0), \".\"), compileProperty);\n\ninstallSpecial(symbol(void(0), \"apply\"), compileApply);\n\ninstallSpecial(symbol(void(0), \"new\"), compileNew);\n\ninstallSpecial(symbol(void(0), \"instance?\"), compileInstance);\n\ninstallSpecial(symbol(void(0), \"not\"), compileNot);\n\ninstallSpecial(symbol(void(0), \"loop\"), compileLoop);\n\ninstallSpecial(symbol(void(0), \"raw*\"), compileRaw);\n\ninstallSpecial(symbol(void(0), \"comment\"), compileComment);\n\nvar compileKeyword = function compileKeyword(form) {\n  return \"\" + \"\\\"\" + \"\" + (name(form)) + \"\\\"\";\n};\nexports.compileKeyword = compileKeyword;\n\nvar compileSymbol = function compileSymbol(form) {\n  return compile(list(symbol(void(0), \"symbol\"), namespace(form), name(form)));\n};\nexports.compileSymbol = compileSymbol;\n\nvar compileNil = function compileNil(form) {\n  return \"void(0)\";\n};\nexports.compileNil = compileNil;\n\nvar compileNumber = function compileNumber(form) {\n  return form;\n};\nexports.compileNumber = compileNumber;\n\nvar compileBoolean = function compileBoolean(form) {\n  return isTrue(form) ?\n    \"true\" :\n    \"false\";\n};\nexports.compileBoolean = compileBoolean;\n\nvar compileString = function compileString(form) {\n  form = replace(form, RegExp(\"\\\\\\\\\", \"g\"), \"\\\\\\\\\");\n  form = replace(form, RegExp(\"\\n\", \"g\"), \"\\\\n\");\n  form = replace(form, RegExp(\"\\r\", \"g\"), \"\\\\r\");\n  form = replace(form, RegExp(\"\\t\", \"g\"), \"\\\\t\");\n  form = replace(form, RegExp(\"\\\"\", \"g\"), \"\\\\\\\"\");\n  return \"\" + \"\\\"\" + form + \"\\\"\";\n};\nexports.compileString = compileString;\n\nvar compileRePattern = function compileRePattern(form) {\n  return \"\" + form;\n};\nexports.compileRePattern = compileRePattern;\n\nvar installNative = function installNative(alias, operator, validator, fallback) {\n  return installSpecial(alias, function(form) {\n    return isEmpty(form) ?\n      fallback :\n      reduce(function(left, right) {\n        return compileTemplate(list(\"~{} ~{} ~{}\", left, name(operator), right));\n      }, map(function(operand) {\n        return compileTemplate(list(isList(operand) ?\n          \"(~{})\" :\n          \"~{}\", compile(macroexpand(operand))));\n      }, form));\n  }, validator);\n};\nexports.installNative = installNative;\n\nvar installOperator = function installOperator(alias, operator) {\n  return installSpecial(alias, function(form) {\n    return (function loop(result, left, right, operands) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = isEmpty(operands) ?\n        \"\" + result + (compileTemplate(list(\"~{} ~{} ~{}\", compile(macroexpand(left)), name(operator), compile(macroexpand(right))))) :\n        (result = \"\" + result + (compileTemplate(list(\"~{} ~{} ~{} && \", compile(macroexpand(left)), name(operator), compile(macroexpand(right))))), left = right, right = first(operands), operands = rest(operands), loop);\n      };\n      return recur;\n    })(\"\", first(form), second(form), rest(rest(form)));\n  }, verifyTwo);\n};\nexports.installOperator = installOperator;\n\nvar compilerError = function compilerError(form, message) {\n  var error = Error(\"\" + message);\n  error.line = 1;\n  return (function() { throw error; })();\n};\nexports.compilerError = compilerError;\n\nvar verifyTwo = function verifyTwo(form) {\n  return (isEmpty(rest(form))) || (isEmpty(rest(rest(form)))) ?\n    (function() { throw compilerError(form, \"\" + (first(form)) + \" form requires at least two operands\"); })() :\n    void(0);\n};\nexports.verifyTwo = verifyTwo;\n\ninstallNative(symbol(void(0), \"+\"), symbol(void(0), \"+\"), void(0), 0);\n\ninstallNative(symbol(void(0), \"-\"), symbol(void(0), \"-\"), void(0), \"NaN\");\n\ninstallNative(symbol(void(0), \"*\"), symbol(void(0), \"*\"), void(0), 1);\n\ninstallNative(symbol(void(0), \"/\"), symbol(void(0), \"/\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"mod\"), symbol(\"%\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"and\"), symbol(void(0), \"&&\"));\n\ninstallNative(symbol(void(0), \"or\"), symbol(void(0), \"||\"));\n\ninstallOperator(symbol(void(0), \"not=\"), symbol(void(0), \"!=\"));\n\ninstallOperator(symbol(void(0), \"==\"), symbol(void(0), \"===\"));\n\ninstallOperator(symbol(void(0), \"identical?\"), symbol(void(0), \"===\"));\n\ninstallOperator(symbol(void(0), \">\"), symbol(void(0), \">\"));\n\ninstallOperator(symbol(void(0), \">=\"), symbol(void(0), \">=\"));\n\ninstallOperator(symbol(void(0), \"<\"), symbol(void(0), \"<\"));\n\ninstallOperator(symbol(void(0), \"<=\"), symbol(void(0), \"<=\"));\n\ninstallNative(symbol(void(0), \"bit-and\"), symbol(void(0), \"&\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-or\"), symbol(void(0), \"|\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-xor\"), symbol(\"^\"));\n\ninstallNative(symbol(void(0), \"bit-not\"), symbol(\"~\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-left\"), symbol(void(0), \"<<\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-right\"), symbol(void(0), \">>\"), verifyTwo);\n\ninstallNative(symbol(void(0), \"bit-shift-right-zero-fil\"), symbol(void(0), \">>>\"), verifyTwo);\n\ninstallMacro(symbol(void(0), \"str\"), function str() {\n  var forms = Array.prototype.slice.call(arguments, 0);\n  return concat(list(symbol(void(0), \"+\"), \"\"), forms);\n});\n\ninstallMacro(symbol(void(0), \"let\"), function letMacro(bindings) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return cons(symbol(void(0), \"do\"), concat(defineBindings(bindings), body));\n});\n\ninstallMacro(symbol(void(0), \"cond\"), function cond() {\n  var clauses = Array.prototype.slice.call(arguments, 0);\n  return !(isEmpty(clauses)) ?\n    list(symbol(void(0), \"if\"), first(clauses), isEmpty(rest(clauses)) ?\n      (function() { throw Error(\"cond requires an even number of forms\"); })() :\n      second(clauses), cons(symbol(void(0), \"cond\"), rest(rest(clauses)))) :\n    void(0);\n});\n\ninstallMacro(symbol(void(0), \"defn\"), function defn(name) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return list(symbol(void(0), \"def\"), name, concat(list(symbol(void(0), \"fn\"), name), body));\n});\n\ninstallMacro(symbol(void(0), \"defn-\"), function defn(name) {\n  var body = Array.prototype.slice.call(arguments, 1);\n  return concat(list(symbol(void(0), \"defn\"), withMeta(name, conj({\n    \"private\": true\n  }, meta(name)))), body);\n});\n\ninstallMacro(symbol(void(0), \"assert\"), function assert(x, message) {\n  var title = message || \"\";\n  var assertion = prStr(x);\n  var uri = (x || 0)[\"uri\"];\n  var form = isList(x) ?\n    second(x) :\n    x;\n  return list(symbol(void(0), \"do\"), list(symbol(void(0), \"if\"), list(symbol(void(0), \"and\"), list(symbol(void(0), \"not\"), list(symbol(void(0), \"identical?\"), list(symbol(void(0), \"typeof\"), symbol(void(0), \"**verbose**\")), \"undefined\")), symbol(void(0), \"**verbose**\")), list(symbol(void(0), \".log\"), symbol(void(0), \"console\"), \"Assert:\", assertion)), list(symbol(void(0), \"if\"), list(symbol(void(0), \"not\"), x), list(symbol(void(0), \"throw\"), list(symbol(void(0), \"Error.\"), list(symbol(void(0), \"str\"), \"Assert failed: \", title, \"\\n\\nAssertion:\\n\\n\", assertion, \"\\n\\nActual:\\n\\n\", form, \"\\n--------------\\n\"), uri))));\n});\n\ninstallMacro(symbol(void(0), \"import\"), function(imports, path) {\n  return isNil(path) ?\n    list(symbol(void(0), \"require\"), imports) :\n  isSymbol(imports) ?\n    list(symbol(void(0), \"def\"), withMeta(imports, {\n      \"private\": true\n    }), list(symbol(void(0), \"require\"), path)) :\n    (function loop(form, names) {\n      var recur = loop;\n      while (recur === loop) {\n        recur = isEmpty(names) ?\n        concat(list(symbol(void(0), \"do*\")), form) :\n        (function() {\n          var alias = first(names);\n          var id = symbol(\"\" + \".-\" + (name(alias)));\n          return (form = cons(list(symbol(void(0), \"def\"), withMeta(alias, {\n            \"private\": true\n          }), list(id, list(symbol(void(0), \"require\"), path))), form), names = rest(names), loop);\n        })();\n      };\n      return recur;\n    })(list(), imports);\n})\n\n//@ sourceURL=/lib/compiler.js"));

require.define("/support/embed.js",Function(['require','module','exports','__dirname','__filename','process'],"var rest = (require(\"../lib/sequence\")).rest;;\n\nvar str = (require(\"../lib/runtime\")).str;;\n\nvar transpile = (require(\"../lib/engine/browser\")).transpile;;\n\nvar readFromString = (require(\"../lib/reader\")).readFromString;;\n\nvar compileProgram = (require(\"../lib/compiler\")).compileProgram;;\n\nvar updatePreview = function updatePreview(editor) {\n  clearTimeout(updatePreview.id);\n  return (function() {\n    var code = editor.getValue();\n    localStorage.buffer = code;\n    return updatePreview.id = setTimeout(function() {\n      return (function() {\n      try {\n        editor.clearMarker(updatePreview.line || 1);\n        return output.setValue(transpile(code));\n      } catch (error) {\n        updatePreview.line = error.line;\n        return editor.setMarker(error.line || 0, \"\" + \"<span title='\" + error.message + \"'></span> %N%\");\n      }})();\n    }, 200);\n  })();\n};\nexports.updatePreview = updatePreview;\n\nvar input = CodeMirror(document.getElementById(\"input\"), {\n  \"lineNumbers\": true,\n  \"autoClearEmptyLines\": true,\n  \"tabSize\": 2,\n  \"indentWithTabs\": false,\n  \"electricChars\": true,\n  \"mode\": \"clojure\",\n  \"theme\": \"ambiance\",\n  \"autofocus\": true,\n  \"fixedGutter\": true,\n  \"matchBrackets\": true,\n  \"value\": localStorage.buffer || ((document.getElementById(\"examples\")).innerHTML),\n  \"onChange\": updatePreview,\n  \"onCursorActivity\": function() {\n    input.setLineClass(hlLine, null, null);\n    return hlLine = input.setLineClass((input.getCursor()).line, null, \"activeline\");\n  },\n  \"onGutterClick\": function() {\n    var output = document.getElementById(\"output\");\n    var input = document.getElementById(\"input\");\n    output.hidden = !(output.hidden);\n    return input.style.width = output.hidden ?\n      \"100%\" :\n      \"50%\";\n  }\n});\nexports.input = input;\n\nvar hlLine = input.setLineClass(0, void(0), \"activeline\");\nexports.hlLine = hlLine;\n\nvar output = CodeMirror(document.getElementById(\"output\"), {\n  \"lineNumbers\": true,\n  \"fixedGutter\": true,\n  \"matchBrackets\": true,\n  \"mode\": \"javascript\",\n  \"theme\": \"ambiance\",\n  \"readOnly\": true\n});\nexports.output = output;\n\nsetTimeout(updatePreview, 1000, input)\n\n//@ sourceURL=/support/embed.js"));
require("/support/embed.js");

